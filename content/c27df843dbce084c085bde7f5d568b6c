<html>
<head>
<title>Teach Yourself Programming in Ten Years</title>
<!-- Changed by: Peter Norvig, 13-Jul-1998 -->
<body bgcolor=ffffff>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />

<center>
<h1>Teach Yourself Programming in Ten Years</h1>
<h3>Peter Norvig</h3>
</center>
<p>

<table cellpadding=4>
<tr>
<td>

<h2>Why is everyone in such a rush?</h2>

Walk into any bookstore, and you'll see how to <i>Teach Yourself Java
in 7 Days</i> alongside endless variations offering to teach Visual
Basic, Windows, the Internet, and so on in a few days or hours.  I did
the following <a href="http://www.amazon.com/exec/obidos/tg/browse/-/468558/104-5938873-6579160">power search</a> at <a
href="http://www.amazon.com">Amazon.com</a>: 

<pre>     <a
href="http://www.amazon.com/exec/obidos/search-handle-url/ix=books&rank=%2Bfeaturedrank&fqp=power%01pubdate%3A%20after%201992%20and%20title%3A%20days%20and%0D%20%28title%3A%20learn%20or%20title%3A%20teach%20yourself%29&sz=25&pg=1/ref=s_b_np">pubdate: after 1992 and title: days and</a>
      <a
href="http://www.amazon.com/exec/obidos/search-handle-url/ix=books&rank=%2Bfeaturedrank&fqp=power%01pubdate%3A%20after%201992%20and%20title%3A%20days%20and%0D%20%28title%3A%20learn%20or%20title%3A%20teach%20yourself%29&sz=25&pg=1/ref=s_b_np">(title: learn or title: teach yourself)</a></pre>

and got back 248 hits.  The first 78 were computer books (number 79
was <a
href="http://www.amazon.com/exec/obidos/ASIN/0781802245/"><i>Learn
Bengali in 30 days</i></a>).  I replaced "days" with <a
href="http://www.amazon.com/exec/obidos/search-handle-url/ix=books&rank=%2Bfeaturedrank&fqp=power%01pubdate%3A%20after%201992%20and%20title%3A%20hours%20and%0D%20%28title%3A%20learn%20or%20title%3A%20teach%20yourself%29&sz=25&pg=3/ref=s_b_np">"hours"</a>
and got remarkably similar results: 253 more books, with 77 computer
books followed by <a
href="http://www.amazon.com/exec/obidos/ASIN/0028638999/"><i>Teach
Yourself Grammar and Style in 24 Hours</i></a> at number 78. Out of
the top 200 total, 96% were computer books.  

<p>The conclusion is that either people are in a big rush to learn
about computers, or that computers are somehow fabulously easier to
learn than anything else.  There are no books on how to learn
Beethoven, or Quantum Physics, or even Dog Grooming in a few days.
Felleisen <i>et al.</i>
give a nod to this trend in their book <i><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html">How to Design Programs</a></i>, when they say
"Bad programming is easy. <i>Idiots</i> can learn it in <i>21 days</i>,
even if they are <i>dummies</i>.

<p> Let's analyze what a title like <i><a href="http://www.amazon.com/Learn-C-Three-Days-Rachele/dp/1556227078">Learn C++ in Three Days</a></i>
could mean:
<ul>

<li><b>Learn:</b> In 3 days you won't have time to write several
significant programs, and learn from your successes and failures with
them.  You won't have time to work with an experienced programmer and
understand what it is like to live in a C++ environment.  In short, you
won't have time to learn much.  So the book can only be talking about a
superficial familiarity, not a deep understanding. As Alexander Pope said,
a little learning is a dangerous thing.<p>

<li><b>C++:</b> In 3 days you might be able to learn some of the syntax of
C++ (if you already know another language), but you couldn't
learn much about how to use the language.  In short, if you were, say, a
Basic programmer, you could learn to write programs in the style of
Basic using C++ syntax, but you couldn't learn what C++ is
actually good (and bad) for.  So what's the point?  <a
href="http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html">Alan
Perlis</a> once said: "A language that doesn't affect the way you
think about programming, is not worth knowing".  One possible point is
that you have to learn a tiny bit of C++ (or more likely, something
like JavaScript or Flash's Flex) because you need to interface with an
existing tool to accomplish a specific task. But then you're not
learning how to program; you're learning to accomplish that task.<p>

<li><b>in Three Days:</b> Unfortunately, this is not enough, as the next
section shows.
</ul>

<h2>Teach Yourself Programming in Ten Years</h2>

Researchers (<a
href="http://www.amazon.com/exec/obidos/ASIN/034531509X/">Bloom
(1985)</a>, <a href="#bh">Bryan &amp; Harter (1899)</a>, <a
href="http://www.amazon.com/exec/obidos/ASIN/0805803092">Hayes
(1989)</a>, <a href="#sc">Simmon &amp; Chase (1973)</a>) have shown it
takes about ten years to develop expertise in any of a wide variety of
areas, including chess playing, music composition, telegraph
operation, painting, piano playing, swimming, tennis, and research in
neuropsychology and topology.  The key is <i>deliberative</i>
practice: not just doing it again and again, but challenging yourself
with a task that is just beyond your current ability, trying it,
analyzing your performance while and after doing it, and correcting
any mistakes.  Then repeat.  And repeat again.  There appear to be no
real shortcuts: even Mozart, who was a musical prodigy at age 4, took
13 more years before he began to produce world-class music.  In
another genre, the Beatles seemed to burst onto the scene with a
string of #1 hits and an appearance on the Ed Sullivan show in 1964.
But they had been playing small clubs in Liverpool and Hamburg since
1957, and while they had mass appeal early on, their first great
critical success, <i>Sgt. Peppers</i>, was released in 1967. 
<a href="http://www.amazon.com/Outliers-Story-Success-Malcolm-Gladwell/dp/0316017922">Malcolm
Gladwell</a> reports that a study of students at the Berlin Academy of
Music compared the top, middle, and bottom third of the class and
asked them how much they had practiced:
<blockquote>
Everyone, from all three groups, started playing at roughly the same
time - around the age of five. In those first few years, everyone
practised roughly the same amount - about two or three hours a
week. But around the age of eight real differences started to
emerge. The students who would end up as the best in their class began
to practise more than everyone else: six hours a week by age nine,
eight by age 12, 16 a week by age 14, and up and up, until by the age
of 20 they were practising well over 30 hours a week. By the age of
20, the elite performers had all totalled 10,000 hours of practice
over the course of their lives. The merely good students had totalled,
by contrast, 8,000 hours, and the future music teachers just over
4,000 hours.
</blockquote>
<p>
So it may be that 10,000 hours, not 10 years, is the magic number.
Samuel Johnson (1709-1784) thought it
took longer: "Excellence in any department can be
attained only by the labor of a lifetime; it is not to be purchased at
a lesser price."  And Chaucer (1340-1400) complained "the lyf so short, the craft
so long to lerne." Hippocrates (c. 400BC) is known for the excerpt "ars longa,
vita brevis", which is part of the longer quotation "Ars longa, vita
brevis, occasio praeceps, experimentum periculosum, iudicium
difficile", which in English renders as "Life is short, [the] craft
long, opportunity fleeting, experiment treacherous, judgment
difficult."  Although in Latin, <i>ars</i> can mean either art or
craft, in the original Greek the word "techne" can only mean "skill", not "art".


<p>
Here's my recipe for programming success:
<ul>

<li> Get interested in programming, and do some because it is fun.  Make sure
that it keeps being enough fun so that you will be willing to put in ten years.<p>

<li> Talk to other programmers; read other programs.  This is more important
than any book or training course.<p>

<li> Program.  The best kind of learning is <a
href="http://www.engines4ed.org/hyperbook/nodes/NODE-120-pg.html">learning
by doing</a>.  To put it more technically, "the maximal level of
performance for individuals in a given domain is not attained
automatically as a function of extended experience, but the level of
performance can be increased even by highly experienced individuals as
a result of deliberate efforts to improve." <a
href="http://www2.umassd.edu/swpi/DesignInCS/expertise.html">(p. 366)</a>
and "the most effective learning requires a well-defined task with an
appropriate difficulty level for the particular individual,
informative feedback, and opportunities for repetition and corrections
of errors." (p. 20-21)  The book <i>
<a href="http://www.amazon.com/exec/obidos/ASIN/0521357349">Cognition in Practice: Mind, Mathematics, and Culture in Everyday
Life</a></i> is an interesting 
reference for this viewpoint.<p>

<li> If you want, put in four years at a college (or more at a
graduate school).  This will give you access to some jobs that require
credentials, and it will give you a deeper understanding of the field,
but if you don't enjoy school, you can (with some dedication) get
similar experience on the job. In any case, book learning alone won't
be enough. "Computer science education cannot make anybody an expert
programmer any more than studying brushes and pigment can make
somebody an expert painter" says Eric Raymond, author of <I>The New
Hacker's Dictionary</I>. One of the best programmers I ever hired had
only a High School degree; he's produced a lot of <A
HREF="http://www.xemacs.org">great</A> <A
HREF="http://www.mozilla.org">software</A>, has his own <a
href="http://groups.google.com/groups?q=alt.fan.jwz&meta=site%3Dgroups">news group</a>, and made enough in stock options to buy his own <a href="http://en.wikipedia.org/wiki/DNA_Lounge">nightclub</a>.

<li> Work on projects with other programmers. Be the best programmer
on some projects; be the worst on some others.  When you're the best,
you get to test your abilities to lead a project, and to inspire
others with your vision.  When you're the worst, you learn what the
masters do, and you learn what they don't like to do (because they
make you do it for them).<p>

<li> Work on projects <i>after</i> other programmers. Be involved in
understanding a program written by someone else. See what it takes to
understand and fix it when the original programmers are not
around. Think about how to design your programs to make it easier for
those who will maintain it after you.<p>

<li> Learn at least a half dozen programming languages.  Include one
language that supports class abstractions (like Java or C++), one that
supports functional abstraction (like Lisp or ML), one
that supports syntactic abstraction (like Lisp), one
that supports declarative specifications (like Prolog or C++
templates), one that supports coroutines (like Icon or Scheme), and
one that supports parallelism (like Sisal).  <p>

<li> Remember that there is a "computer" in "computer science". Know
how long it takes your computer to execute an instruction, fetch a
word from memory (with and without a cache miss), read consecutive words from disk, and seek to a new location on disk. (<a href="#answers">Answers here.</a>) <p>

<li> Get involved in a language
standardization effort.  It could be the ANSI C++ committee, or it
could be deciding if your local coding style will have 2 or 4 space
indentation levels.  Either way, you learn about what other people
like in a language, how deeply they feel so, and perhaps even a little
about why they feel so.<p>

<li> Have the good sense to get off the language standardization effort as
quickly as possible.
</ul>

With all that in mind, its questionable how far you can get just by
book learning.  Before my first child was born, I read all the <i>How
To</i> books, and still felt like a clueless novice.  30 Months later,
when my second child was due, did I go back to the books for a
refresher? No.  Instead, I relied on my personal experience, which
turned out to be far more useful  and reassuring
to me than the thousands of pages written
by experts.

<p>Fred Brooks, in his essay <I><a href="http://en.wikipedia.org/wiki/No_Silver_Bullet">No Silver Bullet</a></I> 
identified a three-part plan for finding great
software designers:

<ol>
   <li>Systematically identify top designers as early as possible.<p> 
   <li>Assign a career mentor to be responsible for the development of the prospect and carefully keep a career file.<p>
   <li>Provide opportunities for growing designers to interact and stimulate each other.<p>
</ol>

This assumes that some people already have the qualities necessary for
being a great designer; the job is to properly coax them along.  <a
href="http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html">Alan
Perlis</a> put it more succinctly: "Everyone can be taught to sculpt:
Michelangelo would have had to be taught how not to. So it is with the
great programmers".

<p>
So go ahead and buy that Java book; you'll probably get some use out of it.
But you won't change your life, or your real overall expertise as a
programmer in 24 hours, days, or even months.
<p>

<hr>
<h2>References</h2>

<p>
Bloom, Benjamin (ed.) <i><a href="http://www.amazon.com/exec/obidos/ASIN/034531509X">Developing Talent in Young People</a></i>, Ballantine, 1985.

<p>
Brooks, Fred, <i><a href="http://citeseer.nj.nec.com/context/7718/0">No Silver Bullets</a></i>, IEEE Computer, vol. 20, no. 4, 1987, p. 10-19.

<p>
<a name="bh">Bryan, W.L. &amp; Harter, N. "Studies on the telegraphic language:
The acquisition of a hierarchy of habits. <i>Psychology Review</i>,
1899, 8, 345-375</a>
<p>
Hayes, John R., <i><a href="http://www.amazon.com/exec/obidos/ASIN/0805803092">Complete Problem Solver</a></i> Lawrence Erlbaum, 1989.

<p>
<a name="cs">Chase, William G. &amp; Simon, Herbert A.  
<a href="http://books.google.com/books?id=dYPSHAAACAAJ&dq=%22perception+in+chess%22+simon&ei=z4PyR5iIAZnmtQPbyLyuDQ">"Perception in Chess"</a>
<i>Cognitive Psychology</i>, 1973, 4, 55-81.</a>
<p>
Lave, Jean, <i><a href="http://www.amazon.com/exec/obidos/ASIN/0521357349">Cognition in Practice: Mind, Mathematics, and Culture in Everyday
Life</a></i>, Cambridge University Press, 1988.

<hr>
<a name="answers"><h2>Answers</h2></a>

Approximate timing for various operations on a typical PC:<p>
<table border=1 cellpadding=2 cellspacing=2>
<tr><td>execute typical instruction<td align=right> 1/1,000,000,000 sec = 1 nanosec
<tr><td>fetch from L1 cache memory<td align=right> 0.5 nanosec
<tr><td>branch misprediction<td align=right> 5 nanosec
<tr><td>fetch from L2 cache memory<td align=right> 7 nanosec
<tr><td>Mutex lock/unlock<td align=right> 25 nanosec
<tr><td>fetch from main memory<td align=right> 100 nanosec 
<tr><td>send 2K bytes over 1Gbps network<td align=right> 20,000 nanosec
<tr><td>read 1MB sequentially from memory<td align=right> 250,000 nanosec
<tr><td>fetch from new disk location (seek)<td align=right> 8,000,000 nanosec
<tr><td>read 1MB sequentially from disk<td align=right> 20,000,000 nanosec
<tr><td>send packet US to Europe and back<td align=right> 150 milliseconds = 150,000,000 nanosec
</table>
 

<hr>
<h2>Appendix: Language Choice</h2>

Several people have asked what programming language they should learn first.
There is no one answer, but consider these points:

<p>
<ul>

<li><i>Use your friends</i>. When asked "what operating system should
I use, Windows, Unix, or Mac?", my answer is usually: "use whatever
your friends use."  The advantage you get from learning from your
friends will offset any intrinsic difference between OS, or
between programming languages.  Also consider your future friends:
the community of programmers that you will be a part of if you
continue.  Does your chosen language have a large growing community
or a small dying one?  Are there books, web sites, and online forums
to get answers from?  Do you like the people in those forums?

<li><i>Keep it simple</i>.  Programming languages such as C++
and Java are designed for professional development by large teams of
experienced programmers who are concerned about the run-time efficiency of
their code.
As a result, these languages have complicated parts designed for these circumstances.
You're concerned with learning to program.  You don't need that complication.
You want a language that was designed to be easy to learn and remember by a
single new programmer.

<li><i>Play.</i> Which way would you rather learn to play the piano: the
normal, interactive way, in which you hear each note as soon as you hit a key,
or "batch" mode, in which you only hear the notes after you finish a whole song?
Clearly, interactive mode makes learning easier for the piano, and also for 
programming. Insist on a language with an interactive mode and use it.

</ul>

Given these criteria, my recommendations for a first programming
language would be <b><a href="http://python.org">Python</a></b> or
<b><a href="http://www.schemers.org">Scheme</a></b>.  But your
circumstances may vary, and there are other good choices. If your
age is a single-digit, you might prefer
<a href="http://alice.org">Alice</a> or <a href="http://www.squeak.org/">Squeak</a> (older learners might also enjoy these). The important
thing is that you choose and get started.

<hr>

<h2>Appendix: Books and Other Resources</h2>


Several people have asked what books and web pages they should learn
from.  I repeat that "book learning alone won't be enough" but I can
recommend the following:

<p>
<ul>
<li> <b>Scheme:</b> <a
href="http://www.amazon.com/gp/product/0262011530">Structure and
Interpretation of Computer Programs (Abelson &amp; Sussman)</a> is
probably the best introduction to computer science, and it does
teach programming as a way of understanding the computer science. 
You can see <a href="http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/">online videos of lectures</a> on this book, as well as the <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">complete text online</a>. The book is
challenging and will weed out some people who perhaps could be
successful with another approach.  

<li> <b>Scheme:</b>
<a href="http://www.amazon.com/gp/product/0262062186">How to
Design Programs (Felleisen <i>et al.</i>)</a> is one of the best books
on how to actually design programs in an elegant and functional way.

<li> <b>Python:</b> 
<a href="http://www.amazon.com/gp/product/1887902996">Python Programming:
An Intro to CS (Zelle)</a> is a good introduction using Python.  

<li> <b>Python:</b> Several
online <a href="http://wiki.python.org/moin/BeginnersGuide">tutorials</a>
 are available at <a href="http://python.org">Python.org</a>.

<li> <b>Oz:</b> <a href="http://www.amazon.com/gp/product/0262220695">Concepts,
Techniques, and Models of Computer Programming (Van Roy &amp; Haridi)</a>
is seen by some as the modern-day successor to Abelson &amp; Sussman.
It is a tour through the big ideas of programming, covering a wider
range than Abelson &amp; Sussman while being perhaps easier to read and
follow.  It uses a language, Oz, that is not widely known but serves as
a basis for learning other languages.

<
</ul>

<p>


<hr>
<h2>Notes</h2>
T. Capey points out that the <a
  href="http://www.amazon.com/exec/obidos/ASIN/0805803092">Complete
  Problem Solver</a> page on Amazon now has the "Teach Yourself
  Bengali in 21 days" and "Teach Yourself Grammar and Style" books under the
  "Customers who shopped for this item also shopped for these items"
  section.  I guess that a large portion of the people who look at that
  book are coming from this page.
Thanks to Ross Cohen for help with Hippocrates.
</ol>

<td>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<td valign=top bgcolor="#eeeeee">
<h2>Translations</h2>
Thanks to the
following authors,
translations of 
this page are
available in:

<hr>
<a href="http://www.myahya.org/writing/21-days">Arabic<br>(Mohamed A. Yahya)
<br><img width=150 height=56 src="150px-Arabic_Text.png">

<hr>
<a href="http://www.javaresearch.org/article/showarticle.jsp?column=451&thread=12568">Chinese <br>(Xiaogang Guo)
<br><img width=82 height=54  src="ch-flag.gif"></a>


<hr>
<a href="http://tvrtko.bedekovic.net/home/articles/programming/21-days.html">Croatian
<br>(Tvrtko Bedekovic)
<br><img src="hr-flag.gif" height=55 width=108></a>


<hr><a href="http://www.vizmatic.com/apprenez-a-programmer-en-dix-ans/lang/fr">French <br>(Etienne Beauchesne)
<br><img width=81 height=54  src="fr-flag.gif">
</a>

<hr>
<a href="http://purl.net/stefan_ram/html/21-tage">German <br>(Stefan Ram)
<br><img width=89 height=54  src="gm-flag.gif"></a>

<hr>
<a href="http://www.reviewsnest.com/charities/programmingin10years.htm">Hebrew 
<br>(Eric McCain)
<br><img width=150 height=56 src="heb-150.png"></a>

<hr>
<a href="http://vikashtiwari.blogspot.com/2008/04/teach-yourself-programming-in-10-years.html">Hindi<br>
(Vikash Tiwari)
<br><img src="in-flag.gif"></a>

<hr>
<a href="http://mestyanm.extra.hu/doc/21_nap.html">Hungarian<br>
(Marton Mestyan)
<br><img src="hu-flag.gif" width=81 height=54></a>

<hr>
<a href="http://djitz.com/djitzlosophy/belajar-programming-sendiri-dalam-sepuluh-tahun/">Indonesian<br>
(Tridjito Santoso)
<br><img src="id-flag.png" width=81 height=54></a>

<hr>
<a href="http://www.culturahacker.it/documenti/teach.html">Italian<br>
(Fabio Z. Tessitore)
<br><img width=81 height=54 src="it-flag.gif"></a>

<hr>
<a href="http://www.yamdas.org/column/technique/21-daysj.html">Japanese <br>(yomoyomo)
<br><img width=81 height=54  src="ja-flag.gif"></a>

<hr>
<a href="http://www.tavon.org/site/work/21-days">Korean 
(John Hwang)
<br><img width=81 height=54 src="ks-flag.gif"></a>

<hr>
<a href="http://barnamenevis.org/forum/showthread.php?t=150950">Persian<br>(Mehdi Asgari)
<br><img width=87 height=54 src="ir-flag.gif"></a>
<hr>
<a href="http://jnowak.students.wmid.amu.edu.pl/norvig.html">Polish<br>(Kuba Nowak)
<br><img width=87 height=54 src="pl-flag.gif"></a>

<hr>
<a href="http://pihisall.wordpress.com/2007/03/15/aprenda-a-programar-em-dez-anos/">Portugese<br>(Augusto Radtke)
<br><img width=74 height=54 src="br-flag.gif"></a>

<hr>
<a href="http://norvig.com/romanian21-days.html">Romanian<br>(&#350;tefan Laz&#259;r)
<br><img width=80 height=54 src="ro-flag.gif"></a>

<hr>
<a href="http://www.williamspublishing.com/21-days.html">Russian<br>(Konstantin Ptitsyn)
<br><img width=81 height=54 src="rs-flag.gif"></a>
<hr>
<a href="http://www.inverudio.com/21-days.htm">Serbian<br>(Lazar Kovacevic)
<br><img width=108 height=54 src="rb-flag.gif"></a>

<hr>
<a href="http://loro.sf.net/notes/21-dias.html">Spanish <br>(Carlos Rueda)
<br><img width=81 height=54  src="sp-flag.gif"></a>

<hr>
<a href="http://www.efton.sk/sk/learn_programming_in_10_years.html">Slovak<br>
(Jan Waclawek)
<br><img width=81 height=54 src="lo-lgflag.gif"></a>

<hr>
<a href="http://ileriseviye.org/arasayfa.php?inode=programmingtenyears.html">Turkish <br>(&Ccedil;a&#287;&#305;l Ulu&#351;ahin)
<br><img width=81 height=54  src="tu-flag.gif">
</a>

<hr>
<script src="http://www.gmodules.com/ig/ifr?url=http://www.google.com/ig/modules/translatemypage.xml&up_source_language=en&w=160&h=60&title=&border=&output=js"></script>
</table>
<p>
<hr>
<A HREF="index.html"><I>Peter Norvig</I> (Copyright 2001)</A>


