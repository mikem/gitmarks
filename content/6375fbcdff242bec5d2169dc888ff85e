<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>A Comprehensive Guide to Zope Component Architecture</title>
<meta name="author" content="Baiju M" />
<style type="text/css">

/*
:Author: Fred L. Drake, Jr.
:date: $Date: 2004/03/31 22:31:05 $
:version: $Revision: 1.7 $

This stylesheet combines some ideas from the two stylesheets
distributed with docutils and enhances them for Zope 3 documentation.
*/

@import url(default.css);

body {
  margin: 0px 1em 1em 4em;
  padding: 0px; }

h1.title {
  font-size: 150%;
  min-height: 42px; }

div.section {
  margin: 0px 0px 1.5em 0px; }

div.section h1 {
  background-color: rgb(230,230,230);
  margin-left: -2em;
  padding: 0.2em;
  padding-left: 0.35em;
  padding-top: 0.35em;
  /* This grey underline make this more visually distinctive on LCD
     monitors, which often don't have enough contrast. */
  border-right: thin solid rgb(180,180,180);
  border-bottom: thin solid rgb(180,180,180); }

div.section div.section div.section h3 {
  margin-left: -1.9em;
  margin-bottom: -0.5em; }

h1 {
  font-family: sans-serif;
  font-size: 135%; }

h2 {
  font-family: sans-serif;
  font-size: 120%; }

h3 {
  font-family: sans-serif;
  font-size: 105%; }

h4 {
  font-family: sans-serif;
  font-size: 100%; }

h5 {
  font-family: sans-serif;
  font-size: 100%; }

h6 {
  font-family: sans-serif;
  font-style: italic;
  font-size: 100%; }

hr {
  width: 75%; }

.literal .pre {
  background-color: white;
  font-family: lucidatypewriter, "lucida typewriter", sans-serif; }

.literal-block {
  border: thin solid rgb(180,180,180);
  font-family: lucidatypewriter, "lucida typewriter", monospace;
  font-size: 80%;
  padding: 0.5em; }

table.table {
  margin-left: 2em;
  margin-right: 2em; }

table.table thead {
  background-color: rgb(230,230,230); }

dt {
  font-weight: bold; }

/* docutils uses the "option" class with both "col" and "span"
   elements, so we have to be explicit here */
.option-list span.option {
  font-weight: bold; }

.option-list kbd {
  font-family: inherit; }

</style>
</head>
<body>
<div class="document" id="a-comprehensive-guide-to-zope-component-architecture">
<h1 class="title">A Comprehensive Guide to Zope Component Architecture</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Baiju M</td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>0.5.7</td></tr>
<tr class="field"><th class="docinfo-name">Printed Book:</th><td class="field-body"><a class="reference" href="http://www.lulu.com/content/1561045">http://www.lulu.com/content/1561045</a></td>
</tr>
<tr class="field"><th class="docinfo-name">Online PDF:</th><td class="field-body"><a class="reference" href="http://www.muthukadan.net/docs/zca.pdf">http://www.muthukadan.net/docs/zca.pdf</a></td>
</tr>
</tbody>
</table>
<p>Copyright (C) 2007,2008,2009 Baiju M &lt;baiju.m.mail AT gmail.com&gt;.</p>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
(at your option) any later version published by the Free Software
Foundation.</p>
<p>The source code in this document is subject to the provisions of the
Zope Public License, Version 2.1 (ZPL).</p>
<p>THE SOURCE CODE IN THIS DOCUMENT AND THE DOCUMENT ITSELF IS PROVIDED
&quot;AS IS&quot; AND ANY AND ALL EXPRESS OR IMPLIED WARRANTIES ARE DISCLAIMED,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS FOR A PARTICULAR
PURPOSE.</p>
<div class="sidebar">
<p class="first sidebar-title">Acknowledgements</p>
<p class="last">Many people have helped me to write this book.  The initial draft
was reviewed by my colleague Brad Allen.  When I announced this
book through my blog, I received many encouraging comments to
proceed with this work.  Kent Tenney edited most parts of the book,
he also rewrote the example application.  Many others sent me fixes
and comments including, Lorenzo Gil Sanchez, Michael Haubenwallner,
Nando Quintana, Stephane Klein, Tim Cook, Kamal Gill and Thomas
Herve.  Lorenzo translated this work to Spanish and Stephane
translated it to French.  Thanks to all !</p>
</div>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#getting-started" id="id19" name="id19">1&nbsp;&nbsp;&nbsp;Getting started</a><ul class="auto-toc">
<li><a class="reference" href="#introduction" id="id20" name="id20">1.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#a-brief-history" id="id21" name="id21">1.2&nbsp;&nbsp;&nbsp;A brief history</a></li>
<li><a class="reference" href="#installation" id="id22" name="id22">1.3&nbsp;&nbsp;&nbsp;Installation</a></li>
<li><a class="reference" href="#experimenting-with-code" id="id23" name="id23">1.4&nbsp;&nbsp;&nbsp;Experimenting with code</a></li>
</ul>
</li>
<li><a class="reference" href="#an-example" id="id24" name="id24">2&nbsp;&nbsp;&nbsp;An example</a><ul class="auto-toc">
<li><a class="reference" href="#id11" id="id25" name="id25">2.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#procedural-approach" id="id26" name="id26">2.2&nbsp;&nbsp;&nbsp;Procedural approach</a></li>
<li><a class="reference" href="#object-oriented-approach" id="id27" name="id27">2.3&nbsp;&nbsp;&nbsp;Object oriented approach</a></li>
<li><a class="reference" href="#the-adapter-pattern" id="id28" name="id28">2.4&nbsp;&nbsp;&nbsp;The adapter pattern</a></li>
</ul>
</li>
<li><a class="reference" href="#interfaces" id="id29" name="id29">3&nbsp;&nbsp;&nbsp;Interfaces</a><ul class="auto-toc">
<li><a class="reference" href="#id12" id="id30" name="id30">3.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#declaring-interfaces" id="id31" name="id31">3.2&nbsp;&nbsp;&nbsp;Declaring interfaces</a></li>
<li><a class="reference" href="#implementing-interfaces" id="id32" name="id32">3.3&nbsp;&nbsp;&nbsp;Implementing interfaces</a></li>
<li><a class="reference" href="#example-revisited" id="id33" name="id33">3.4&nbsp;&nbsp;&nbsp;Example revisited</a></li>
<li><a class="reference" href="#marker-interfaces" id="id34" name="id34">3.5&nbsp;&nbsp;&nbsp;Marker interfaces</a></li>
<li><a class="reference" href="#invariants" id="id35" name="id35">3.6&nbsp;&nbsp;&nbsp;Invariants</a></li>
</ul>
</li>
<li><a class="reference" href="#adapters" id="id36" name="id36">4&nbsp;&nbsp;&nbsp;Adapters</a><ul class="auto-toc">
<li><a class="reference" href="#implementation" id="id37" name="id37">4.1&nbsp;&nbsp;&nbsp;Implementation</a></li>
<li><a class="reference" href="#registration" id="id38" name="id38">4.2&nbsp;&nbsp;&nbsp;Registration</a></li>
<li><a class="reference" href="#querying-adapter" id="id39" name="id39">4.3&nbsp;&nbsp;&nbsp;Querying adapter</a></li>
<li><a class="reference" href="#retrieving-adapter-using-interface" id="id40" name="id40">4.4&nbsp;&nbsp;&nbsp;Retrieving adapter using interface</a></li>
<li><a class="reference" href="#adapter-pattern" id="id41" name="id41">4.5&nbsp;&nbsp;&nbsp;Adapter pattern</a></li>
</ul>
</li>
<li><a class="reference" href="#utility" id="id42" name="id42">5&nbsp;&nbsp;&nbsp;Utility</a><ul class="auto-toc">
<li><a class="reference" href="#id17" id="id43" name="id43">5.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#simple-utility" id="id44" name="id44">5.2&nbsp;&nbsp;&nbsp;Simple utility</a></li>
<li><a class="reference" href="#named-utility" id="id45" name="id45">5.3&nbsp;&nbsp;&nbsp;Named utility</a></li>
<li><a class="reference" href="#factory" id="id46" name="id46">5.4&nbsp;&nbsp;&nbsp;Factory</a></li>
</ul>
</li>
<li><a class="reference" href="#advanced-adapters" id="id47" name="id47">6&nbsp;&nbsp;&nbsp;Advanced adapters</a><ul class="auto-toc">
<li><a class="reference" href="#multi-adapter" id="id48" name="id48">6.1&nbsp;&nbsp;&nbsp;Multi adapter</a></li>
<li><a class="reference" href="#subscription-adapter" id="id49" name="id49">6.2&nbsp;&nbsp;&nbsp;Subscription adapter</a></li>
<li><a class="reference" href="#handler" id="id50" name="id50">6.3&nbsp;&nbsp;&nbsp;Handler</a></li>
</ul>
</li>
<li><a class="reference" href="#zca-usage-in-zope" id="id51" name="id51">7&nbsp;&nbsp;&nbsp;ZCA usage in Zope</a><ul class="auto-toc">
<li><a class="reference" href="#zcml" id="id52" name="id52">7.1&nbsp;&nbsp;&nbsp;ZCML</a></li>
<li><a class="reference" href="#overrides" id="id53" name="id53">7.2&nbsp;&nbsp;&nbsp;Overrides</a></li>
<li><a class="reference" href="#namechooser" id="id54" name="id54">7.3&nbsp;&nbsp;&nbsp;NameChooser</a></li>
<li><a class="reference" href="#locationphysicallylocatable" id="id55" name="id55">7.4&nbsp;&nbsp;&nbsp;LocationPhysicallyLocatable</a></li>
<li><a class="reference" href="#defaultsized" id="id56" name="id56">7.5&nbsp;&nbsp;&nbsp;DefaultSized</a></li>
<li><a class="reference" href="#zopeversionutility" id="id57" name="id57">7.6&nbsp;&nbsp;&nbsp;ZopeVersionUtility</a></li>
</ul>
</li>
<li><a class="reference" href="#case-study" id="id58" name="id58">8&nbsp;&nbsp;&nbsp;Case study</a><ul class="auto-toc">
<li><a class="reference" href="#id18" id="id59" name="id59">8.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#use-cases" id="id60" name="id60">8.2&nbsp;&nbsp;&nbsp;Use cases</a></li>
<li><a class="reference" href="#overview-of-pygtk-code" id="id61" name="id61">8.3&nbsp;&nbsp;&nbsp;Overview of PyGTK code</a></li>
<li><a class="reference" href="#the-code" id="id62" name="id62">8.4&nbsp;&nbsp;&nbsp;The code</a></li>
<li><a class="reference" href="#pysqlite" id="id63" name="id63">8.5&nbsp;&nbsp;&nbsp;PySQLite</a></li>
<li><a class="reference" href="#zodb" id="id64" name="id64">8.6&nbsp;&nbsp;&nbsp;ZODB</a></li>
<li><a class="reference" href="#conclusions" id="id65" name="id65">8.7&nbsp;&nbsp;&nbsp;Conclusions</a></li>
</ul>
</li>
<li><a class="reference" href="#reference" id="id66" name="id66">9&nbsp;&nbsp;&nbsp;Reference</a><ul class="auto-toc">
<li><a class="reference" href="#adaptedby" id="id67" name="id67">9.1&nbsp;&nbsp;&nbsp;adaptedBy</a></li>
<li><a class="reference" href="#adapter" id="id68" name="id68">9.2&nbsp;&nbsp;&nbsp;adapter</a></li>
<li><a class="reference" href="#adapts" id="id69" name="id69">9.3&nbsp;&nbsp;&nbsp;adapts</a></li>
<li><a class="reference" href="#alsoprovides" id="id70" name="id70">9.4&nbsp;&nbsp;&nbsp;alsoProvides</a></li>
<li><a class="reference" href="#attribute" id="id71" name="id71">9.5&nbsp;&nbsp;&nbsp;Attribute</a></li>
<li><a class="reference" href="#classimplements" id="id72" name="id72">9.6&nbsp;&nbsp;&nbsp;classImplements</a></li>
<li><a class="reference" href="#classimplementsonly" id="id73" name="id73">9.7&nbsp;&nbsp;&nbsp;classImplementsOnly</a></li>
<li><a class="reference" href="#classprovides" id="id74" name="id74">9.8&nbsp;&nbsp;&nbsp;classProvides</a></li>
<li><a class="reference" href="#componentlookuperror" id="id75" name="id75">9.9&nbsp;&nbsp;&nbsp;ComponentLookupError</a></li>
<li><a class="reference" href="#createobject" id="id76" name="id76">9.10&nbsp;&nbsp;&nbsp;createObject</a></li>
<li><a class="reference" href="#declaration" id="id77" name="id77">9.11&nbsp;&nbsp;&nbsp;Declaration</a></li>
<li><a class="reference" href="#directlyprovidedby" id="id78" name="id78">9.12&nbsp;&nbsp;&nbsp;directlyProvidedBy</a></li>
<li><a class="reference" href="#directlyprovides" id="id79" name="id79">9.13&nbsp;&nbsp;&nbsp;directlyProvides</a></li>
<li><a class="reference" href="#getadapter" id="id80" name="id80">9.14&nbsp;&nbsp;&nbsp;getAdapter</a></li>
<li><a class="reference" href="#getadapterincontext" id="id81" name="id81">9.15&nbsp;&nbsp;&nbsp;getAdapterInContext</a></li>
<li><a class="reference" href="#getadapters" id="id82" name="id82">9.16&nbsp;&nbsp;&nbsp;getAdapters</a></li>
<li><a class="reference" href="#getallutilitiesregisteredfor" id="id83" name="id83">9.17&nbsp;&nbsp;&nbsp;getAllUtilitiesRegisteredFor</a></li>
<li><a class="reference" href="#getfactoriesfor" id="id84" name="id84">9.18&nbsp;&nbsp;&nbsp;getFactoriesFor</a></li>
<li><a class="reference" href="#getfactoryinterfaces" id="id85" name="id85">9.19&nbsp;&nbsp;&nbsp;getFactoryInterfaces</a></li>
<li><a class="reference" href="#getglobalsitemanager" id="id86" name="id86">9.20&nbsp;&nbsp;&nbsp;getGlobalSiteManager</a></li>
<li><a class="reference" href="#getmultiadapter" id="id87" name="id87">9.21&nbsp;&nbsp;&nbsp;getMultiAdapter</a></li>
<li><a class="reference" href="#getsitemanager" id="id88" name="id88">9.22&nbsp;&nbsp;&nbsp;getSiteManager</a></li>
<li><a class="reference" href="#getutilitiesfor" id="id89" name="id89">9.23&nbsp;&nbsp;&nbsp;getUtilitiesFor</a></li>
<li><a class="reference" href="#getutility" id="id90" name="id90">9.24&nbsp;&nbsp;&nbsp;getUtility</a></li>
<li><a class="reference" href="#handle" id="id91" name="id91">9.25&nbsp;&nbsp;&nbsp;handle</a></li>
<li><a class="reference" href="#implementedby" id="id92" name="id92">9.26&nbsp;&nbsp;&nbsp;implementedBy</a></li>
<li><a class="reference" href="#implementer" id="id93" name="id93">9.27&nbsp;&nbsp;&nbsp;implementer</a></li>
<li><a class="reference" href="#implements" id="id94" name="id94">9.28&nbsp;&nbsp;&nbsp;implements</a></li>
<li><a class="reference" href="#implementsonly" id="id95" name="id95">9.29&nbsp;&nbsp;&nbsp;implementsOnly</a></li>
<li><a class="reference" href="#interface" id="id96" name="id96">9.30&nbsp;&nbsp;&nbsp;Interface</a></li>
<li><a class="reference" href="#moduleprovides" id="id97" name="id97">9.31&nbsp;&nbsp;&nbsp;moduleProvides</a></li>
<li><a class="reference" href="#nolongerprovides" id="id98" name="id98">9.32&nbsp;&nbsp;&nbsp;noLongerProvides</a></li>
<li><a class="reference" href="#provideadapter" id="id99" name="id99">9.33&nbsp;&nbsp;&nbsp;provideAdapter</a></li>
<li><a class="reference" href="#providehandler" id="id100" name="id100">9.34&nbsp;&nbsp;&nbsp;provideHandler</a></li>
<li><a class="reference" href="#providesubscriptionadapter" id="id101" name="id101">9.35&nbsp;&nbsp;&nbsp;provideSubscriptionAdapter</a></li>
<li><a class="reference" href="#provideutility" id="id102" name="id102">9.36&nbsp;&nbsp;&nbsp;provideUtility</a></li>
<li><a class="reference" href="#providedby" id="id103" name="id103">9.37&nbsp;&nbsp;&nbsp;providedBy</a></li>
<li><a class="reference" href="#queryadapter" id="id104" name="id104">9.38&nbsp;&nbsp;&nbsp;queryAdapter</a></li>
<li><a class="reference" href="#queryadapterincontext" id="id105" name="id105">9.39&nbsp;&nbsp;&nbsp;queryAdapterInContext</a></li>
<li><a class="reference" href="#querymultiadapter" id="id106" name="id106">9.40&nbsp;&nbsp;&nbsp;queryMultiAdapter</a></li>
<li><a class="reference" href="#queryutility" id="id107" name="id107">9.41&nbsp;&nbsp;&nbsp;queryUtility</a></li>
<li><a class="reference" href="#registeradapter" id="id108" name="id108">9.42&nbsp;&nbsp;&nbsp;registerAdapter</a></li>
<li><a class="reference" href="#registeredadapters" id="id109" name="id109">9.43&nbsp;&nbsp;&nbsp;registeredAdapters</a></li>
<li><a class="reference" href="#registeredhandlers" id="id110" name="id110">9.44&nbsp;&nbsp;&nbsp;registeredHandlers</a></li>
<li><a class="reference" href="#registeredsubscriptionadapters" id="id111" name="id111">9.45&nbsp;&nbsp;&nbsp;registeredSubscriptionAdapters</a></li>
<li><a class="reference" href="#registeredutilities" id="id112" name="id112">9.46&nbsp;&nbsp;&nbsp;registeredUtilities</a></li>
<li><a class="reference" href="#registerhandler" id="id113" name="id113">9.47&nbsp;&nbsp;&nbsp;registerHandler</a></li>
<li><a class="reference" href="#registersubscriptionadapter" id="id114" name="id114">9.48&nbsp;&nbsp;&nbsp;registerSubscriptionAdapter</a></li>
<li><a class="reference" href="#registerutility" id="id115" name="id115">9.49&nbsp;&nbsp;&nbsp;registerUtility</a></li>
<li><a class="reference" href="#subscribers" id="id116" name="id116">9.50&nbsp;&nbsp;&nbsp;subscribers</a></li>
<li><a class="reference" href="#unregisteradapter" id="id117" name="id117">9.51&nbsp;&nbsp;&nbsp;unregisterAdapter</a></li>
<li><a class="reference" href="#unregisterhandler" id="id118" name="id118">9.52&nbsp;&nbsp;&nbsp;unregisterHandler</a></li>
<li><a class="reference" href="#unregistersubscriptionadapter" id="id119" name="id119">9.53&nbsp;&nbsp;&nbsp;unregisterSubscriptionAdapter</a></li>
<li><a class="reference" href="#unregisterutility" id="id120" name="id120">9.54&nbsp;&nbsp;&nbsp;unregisterUtility</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id19" id="getting-started" name="getting-started">1&nbsp;&nbsp;&nbsp;Getting started</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="introduction" name="introduction">1.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>Developing a large software system is always very complicated.  An
object oriented approach to analysis, design and programming has been
shown to be well suited for dealing with large systems.  Component
based design, and programming using components are becoming very
popular these days.  Component based approach helps you to write and
maintain easily unit-testable software systems.  There are many
frameworks for supporting component based design in different
languages, some are even language neutral.  Examples of these are
Microsoft's COM and Mozilla's XPCOM.</p>
<p><strong>Zope Component Architecture (ZCA)</strong> is a Python framework for
supporting component based design and programming.  It is very well
suited to developing large Python software systems.  The ZCA is not
specific to the Zope web application server: it can be used for
developing any Python application.  Maybe it should be called as
<cite>Python Component Architecture</cite>.</p>
<p>The ZCA is all about using Python objects effectively.  Components
are reusable objects with introspectable interfaces.  An interface is
an object that describes how you work with a particular component.
In other words, component provides an interface implemented in a
class, or any other callable object.  It doesn't matter how the
component is implemented, the important part is that it comply with
its interface contracts.  Using ZCA, you can spread the complexity of
systems over multiple cooperating components.  It helps you to create
two basic kinds of components: <cite>adapter</cite> and <cite>utility</cite>.</p>
<p>There are three core packages related to the ZCA:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">zope.interface</span></tt> is used to define the interface of a component.</li>
<li><tt class="docutils literal"><span class="pre">zope.event</span></tt> provides a simple event system.</li>
<li><tt class="docutils literal"><span class="pre">zope.component</span></tt> deals with creation, registration and
retrieval of components.</li>
</ul>
</blockquote>
<p>Remember, the ZCA is not the components themselves, rather it is
about creating, registering, and retrieving components.  Remember
also, an <cite>adapter</cite> is a normal Python class (or a factory in general)
and <cite>utility</cite> is a normal Python callable object.</p>
<p>The ZCA framework is developed as part of the Zope 3 project.  As
noted earlier, it is a pure Python framework, so it can be used in
any kind of Python application.  Currently Zope 3, Zope 2 and Grok
projects use this framework extensively.  There are many other
projects including non-web applications using it <a class="footnote-reference" href="#projects" id="id1" name="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="projects" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="projects">[1]</a></td><td><a class="reference" href="http://wiki.zope.org/zope3/ComponentArchitecture">http://wiki.zope.org/zope3/ComponentArchitecture</a></td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="a-brief-history" name="a-brief-history">1.2&nbsp;&nbsp;&nbsp;A brief history</a></h2>
<p>The ZCA framework project began in 2001 as part of Zope 3 project.  It
grew out of lessons learned while developing large software systems
using Zope 2.  Jim Fulton was the project leader of this project.
Many people contributed to the design and implementation, including
but not limited to, Stephan Richter, Philipp von Weitershausen, Guido
van Rossum (<em>aka. Python BDFL</em>), Tres Seaver, Phillip J Eby and
Martijn Faassen.</p>
<p>Initially ZCA defined additional components; <cite>services</cite> and <cite>views</cite>,
but the developers came to realize that utility can replace <cite>service</cite>
and multi-adapter can replace <cite>view</cite>.  Now ZCA has a very small
number of core component types: <cite>utilities</cite>, <cite>adapters</cite>,
<cite>subscribers</cite> and <cite>handlers</cite>.  In fact, <cite>subscribers</cite> and <cite>handlers</cite>
are two special types of adapters.</p>
<p>During the Zope 3.2 release cycle, Jim Fulton proposed a major
simplification of ZCA <a class="footnote-reference" href="#proposal" id="id2" name="id2">[2]</a>.  With this simplification, a new
single interface (<cite>IComponentRegistry</cite>) for registration of both
global and local component was created.</p>
<table class="docutils footnote" frame="void" id="proposal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="proposal">[2]</a></td><td><a class="reference" href="http://wiki.zope.org/zope3/LocalComponentManagementSimplification">http://wiki.zope.org/zope3/LocalComponentManagementSimplification</a></td></tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">zope.component</span></tt> package had a long list of dependencies, many
of which were not required for a non Zope 3 application.  During PyCon
2007, Jim Fulton added setuptools' <cite>extras_require</cite> feature to allow
separating out core ZCA functionality from add-on features <a class="footnote-reference" href="#extras" id="id3" name="id3">[3]</a>.</p>
<table class="docutils footnote" frame="void" id="extras" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="extras">[3]</a></td><td><a class="reference" href="http://peak.telecommunity.com/DevCenter/setuptools#declaring-dependencies">http://peak.telecommunity.com/DevCenter/setuptools#declaring-dependencies</a></td></tr>
</tbody>
</table>
<p>In March 2009, Tres Seaver removed dependcencies of
<tt class="docutils literal"><span class="pre">zope.deferredimport</span></tt> and <tt class="docutils literal"><span class="pre">zope.proxy</span></tt>.</p>
<p>Now, The ZCA project is an independent project with it's own release
cycle and Subversion repository.  This project is coming as part the
bigger the Zope framework project <a class="footnote-reference" href="#framework" id="id4" name="id4">[4]</a>.  However, issues and
bugs are still tracked as part of the Zope 3 project <a class="footnote-reference" href="#bugs" id="id5" name="id5">[5]</a>, and
the main zope-dev list is used for development discussions
<a class="footnote-reference" href="#discussions" id="id6" name="id6">[6]</a>.  There is also another general user list for Zope 3
(<cite>zope3-users</cite>) which can be used for any queries about the ZCA
<a class="footnote-reference" href="#z3users" id="id7" name="id7">[7]</a>.</p>
<table class="docutils footnote" frame="void" id="framework" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="framework">[4]</a></td><td><a class="reference" href="http://docs.zope.org/zopeframework/">http://docs.zope.org/zopeframework/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bugs" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="bugs">[5]</a></td><td><a class="reference" href="https://bugs.launchpad.net/zope3">https://bugs.launchpad.net/zope3</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="discussions" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6" name="discussions">[6]</a></td><td><a class="reference" href="http://mail.zope.org/mailman/listinfo/zope-dev">http://mail.zope.org/mailman/listinfo/zope-dev</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="z3users" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="z3users">[7]</a></td><td><a class="reference" href="http://mail.zope.org/mailman/listinfo/zope3-users">http://mail.zope.org/mailman/listinfo/zope3-users</a></td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="installation" name="installation">1.3&nbsp;&nbsp;&nbsp;Installation</a></h2>
<p>The <tt class="docutils literal"><span class="pre">zope.component</span></tt>, package together with the <tt class="docutils literal"><span class="pre">zope.interface</span></tt>
and <tt class="docutils literal"><span class="pre">zope.event</span></tt> packages are the core of Zope component
architecture.  They provide facilities for defining, registering and
looking up components.  The <tt class="docutils literal"><span class="pre">zope.component</span></tt> package and its
dependencies are available in egg format from the Python Package
Index (PyPI) <a class="footnote-reference" href="#pypi" id="id8" name="id8">[8]</a>.</p>
<table class="docutils footnote" frame="void" id="pypi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8" name="pypi">[8]</a></td><td>Repository of Python packages: <a class="reference" href="http://pypi.python.org/pypi">http://pypi.python.org/pypi</a></td></tr>
</tbody>
</table>
<p>You can install <tt class="docutils literal"><span class="pre">zope.component</span></tt> and it's dependencies using
<cite>easy_install</cite> <a class="footnote-reference" href="#easyinstall" id="id9" name="id9">[9]</a></p>
<pre class="literal-block">
$ easy_install zope.component
</pre>
<table class="docutils footnote" frame="void" id="easyinstall" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9" name="easyinstall">[9]</a></td><td><a class="reference" href="http://peak.telecommunity.com/DevCenter/EasyInstall">http://peak.telecommunity.com/DevCenter/EasyInstall</a></td></tr>
</tbody>
</table>
<p>This command will download <tt class="docutils literal"><span class="pre">zope.component</span></tt> and its dependencies
from PyPI and install it in your Python path.</p>
<p>Alternately, you can download <tt class="docutils literal"><span class="pre">zope.component</span></tt> and its dependencies
from PyPI and then install them.  Install packages in the order given
below.  On Windows, you may need binary packages of <tt class="docutils literal"><span class="pre">zope.interface</span></tt>.</p>
<blockquote>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zope.event</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
</ol>
</blockquote>
<p>To install these packages, after downloading them, you can use
<tt class="docutils literal"><span class="pre">easy_install</span></tt> command with argument as the eggs.  (You may also
give all these eggs in the same line.):</p>
<pre class="literal-block">
$ easy_install /path/to/zope.interface-3.x.x.tar.gz
$ easy_install /path/to/zope.event-3.x.x.tar.gz
$ easy_install /path/to/zope.component-3.x.x.tar.gz
</pre>
<p>You can also install these packages after extracting each one
separately.  For example:</p>
<pre class="literal-block">
$ tar zxvf /path/to/zope.interface-3.x.x.tar.gz
$ cd zope.interface-3.x.x
$ python setup.py build
$ python setup.py install
</pre>
<p>These methods will install the ZCA to the <cite>system Python</cite>, in the
<tt class="docutils literal"><span class="pre">site-packages</span></tt> directory, which can cause problems.  In a Zope 3
mailing list post, Jim Fulton recommends against using the system
Python <a class="footnote-reference" href="#systempython" id="id10" name="id10">[10]</a>.  You can use <tt class="docutils literal"><span class="pre">virtualenv</span></tt> and/or
<tt class="docutils literal"><span class="pre">zc.buildout</span></tt> for playing with any Python packages, also good for
deployments.</p>
<table class="docutils footnote" frame="void" id="systempython" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10" name="systempython">[10]</a></td><td><a class="reference" href="http://article.gmane.org/gmane.comp.web.zope.zope3/21045">http://article.gmane.org/gmane.comp.web.zope.zope3/21045</a></td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="experimenting-with-code" name="experimenting-with-code">1.4&nbsp;&nbsp;&nbsp;Experimenting with code</a></h2>
<p>There are two approaches in Python for setting up isolated working
environments for developing Python applications.  <tt class="docutils literal"><span class="pre">virtualenv</span></tt>
created by Ian Biking and <tt class="docutils literal"><span class="pre">zc.buildout</span></tt> created by Jim Fulton are
these two packages.  You can also use these packages together.  Using
these packages you can install <tt class="docutils literal"><span class="pre">zope.component</span></tt> and other
dependencies into an isolated working environment.  This is a good
practice for experimenting with any Python code, and familiarity with
these tools will be beneficial when developing and deploying
applications.</p>
<p><strong>virtualenv</strong></p>
<p>You can install <tt class="docutils literal"><span class="pre">virtualenv</span></tt> using <tt class="docutils literal"><span class="pre">easy_install</span></tt>:</p>
<pre class="literal-block">
$ easy_install virtualenv
</pre>
<p>Then create a new environment like this:</p>
<pre class="literal-block">
$ virtualenv --no-site-packages myve
</pre>
<p>This will create a new virtual environment in the <tt class="docutils literal"><span class="pre">myve</span></tt> directory.
Now, from inside the <tt class="docutils literal"><span class="pre">myve</span></tt> directory, you can install
<tt class="docutils literal"><span class="pre">zope.component</span></tt> and dependencies using <tt class="docutils literal"><span class="pre">easy_install</span></tt> inside
<tt class="docutils literal"><span class="pre">myve/bin</span></tt> directory:</p>
<pre class="literal-block">
$ cd myve
$ ./bin/easy_install zope.component
</pre>
<p>Now you can import <tt class="docutils literal"><span class="pre">zope.interface</span></tt> and <tt class="docutils literal"><span class="pre">zope.component</span></tt> from the
new <tt class="docutils literal"><span class="pre">python</span></tt> interpreter inside <tt class="docutils literal"><span class="pre">myve/bin</span></tt> directory:</p>
<pre class="literal-block">
$ ./bin/python
</pre>
<p>This command will give you a Python prompt which you can use to run
the code in this book.</p>
<p><strong>zc.buildout</strong></p>
<p>Using <tt class="docutils literal"><span class="pre">zc.buildout</span></tt> with <tt class="docutils literal"><span class="pre">zc.recipe.egg</span></tt> recipe you can create
Python interpreter with specified Python eggs.  First, install
<tt class="docutils literal"><span class="pre">zc.buildout</span></tt> using <tt class="docutils literal"><span class="pre">easy_install</span></tt> command.  (You may also do it
inside virtual environment).  To create new buildout to experiment
with Python eggs, first create a directory and initialize it using
<tt class="docutils literal"><span class="pre">buildout</span> <span class="pre">init</span></tt> command:</p>
<pre class="literal-block">
$ mkdir mybuildout
$ cd mybuildout
$ buildout init
</pre>
<p>Now the new <tt class="docutils literal"><span class="pre">mybuildout</span></tt> directory is a buildout.  The default
configuration file for buildout is <cite>buildout.cfg</cite> .  After
initializing, it will be having this content:</p>
<pre class="literal-block">
[buildout]
parts =
</pre>
<p>You can change it like this:</p>
<pre class="literal-block">
[buildout]
parts = py

[py]
recipe = zc.recipe.egg
interpreter = python
eggs = zope.component
</pre>
<p>Now run <tt class="docutils literal"><span class="pre">buildout</span></tt> command available inside <tt class="docutils literal"><span class="pre">mybuildout/bin</span></tt>
directory without any argument.  This will create a new Python
interpreter inside <tt class="docutils literal"><span class="pre">mybuildout/bin</span></tt> directory:</p>
<pre class="literal-block">
$ ./bin/buildout
$ ./bin/python
</pre>
<p>This command will give you a Python prompt which you can use to run
the code in this book.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id24" id="an-example" name="an-example">2&nbsp;&nbsp;&nbsp;An example</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id25" id="id11" name="id11">2.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>Consider a business application for registering guests staying in a
hotel.  Python can implement this in a number of ways.  We will start
with a brief look at a procedural implementation, and then move to a
basic object oriented approach.  As we examine the object oriented
approach, we will see how we can benefit from the classic design
patterns, <cite>adapter</cite> and <cite>interface</cite>.  This will bring us into the
world of the Zope Component Architecture.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="procedural-approach" name="procedural-approach">2.2&nbsp;&nbsp;&nbsp;Procedural approach</a></h2>
<p>In any business application, data storage is very critical.  For
simplicity, this example use a Python dictionary as the storage.  We
will generate unique id's for the dictionary, the associated value
will be a dictionary of details about the booking.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bookings_db = {} #key: unique Id, value: details in a dictionary
</pre>
</blockquote>
<p>A minimal implementation requires a function which we pass the details
of the booking, and a supporting function which provides the the
unique id for the storage dictionary key.</p>
<p>We can get the unique id like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; def get_next_id():
...     db_keys = bookings_db.keys()
...     if db_keys == []:
...         next_id = 1
...     else:
...         next_id = max(db_keys) + 1
...     return next_id
</pre>
<p>As you can see, the <cite>get_next_id</cite> function implementation is very
simple.  The function gets a list of keys and checks for an empty
list. If the list is empty this is our first booking, so we return
<cite>1</cite>. If the list is not empty, we add <cite>1</cite> to the maximum value in the
list and return it.</p>
<p>Now we will use the above function to create entries in the
bookings_db dictionary:</p>
<pre class="literal-block">
&gt;&gt;&gt; def book_room(name, place):
...     next_id = get_next_id()
...     bookings_db[next_id] = {
...     'name': name,
...     'room': place
...     }
</pre>
<p>The requirements of a hotel booking management application require
considering additional data:</p>
<blockquote>
<ul class="simple">
<li>phone numbers</li>
<li>room options</li>
<li>payment methods</li>
<li>...</li>
</ul>
</blockquote>
<p>And code to manage the data:</p>
<blockquote>
<ul class="simple">
<li>cancel a reservation</li>
<li>update a reservation</li>
<li>pay for a room</li>
<li>persist the data</li>
<li>insure security of the data</li>
<li>...</li>
</ul>
</blockquote>
<p>Were we to continue with the procedural example, we would create many
functions, passing data back and forth between them.  As requirements
change and are added, the code becomes harder to maintain and bugs
become harder to find and fix.</p>
<p>We will end our discussion of the procedural approach here. It will be
much easier to provide data persistence, design flexibility and code
testability using objects.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="object-oriented-approach" name="object-oriented-approach">2.3&nbsp;&nbsp;&nbsp;Object oriented approach</a></h2>
<!-- ??? should this paragraph talk about "creating an object for
handling registration" or "creating a class to handle registration"? -->
<p>Our discussion of object oriented design will introduce the <cite>class</cite> which
serves to encapsulate the data, and the code to manage it.</p>
<p>Our main class will be the <cite>FrontDesk</cite>. FrontDesk, or other classes it
delegates to, will know how to manage the data for the hotel.  We will
create <cite>instances</cite> of FrontDesk to apply this knowledge to the
business of running a hotel.</p>
<p>Experience has shown that by consolidating the code and data requirements via
objects, we will end up with a design which is easier to understand,
test, and change.</p>
<p>Lets look at the implementation details of a FrontDesk class:</p>
<pre class="literal-block">
&gt;&gt;&gt; class FrontDesk(object):
...
...     def book_room(self, name, place):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': name,
...         'place': place
...         }
</pre>
<p>In this implementation, the <cite>frontdesk</cite> object (an instance of
<cite>FrontDesk</cite> class) is able to handle the bookings.  We can
use it like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; frontdesk = FrontDesk()
&gt;&gt;&gt; frontdesk.book_room(&quot;Jack&quot;, &quot;Bangalore&quot;)
</pre>
<p>Any real project will involve changing requirements.  In this
case management has decided that each guest must provide a phone
number, so we must change the code.</p>
<p>We can achieve this requirement by adding one argument to the
<cite>book_room</cite> method which will be added to the dictionary of values:</p>
<pre class="literal-block">
&gt;&gt;&gt; class FrontDesk(object):
...
...     def book_room(self, name, place, phone):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': name,
...         'place': place,
...         'phone': phone
...         }
</pre>
<p>In addition to migrating the data to new schema, we now have to change
all calls to FrontDesk.  If we abstract the details of guest into an
object and use it for registration, the code changes can be minimized.
We now can make changes to the details of the guest object and the
calls to FrontDesk won't need to change.</p>
<p>Now we have:</p>
<pre class="literal-block">
&gt;&gt;&gt; class FrontDesk(object):
...
...     def book_room(self, guest):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
<p>We still will have to change code to respond to changing requirements.
This is unavoidable, however, our goal is to minimize those changes,
thereby increasing maintainability.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">When coding, it is important to feel free to make changes without
fear of breaking the application.  The way to get the immediate
feedback required is via automated testing.  With well written
tests (and good version control) you can make changes large or
small with impunity.  A good source of information about this
programming philosophy is the book <cite>Extreme Programming Explained</cite>
by Kent Beck.</p>
</div>
<p>By introducing the guest object, you saved some typing.  More
importantly, the abstraction provided by the guest object made the
system simpler and more understandable.  As a result, the code is
easier to restructure and maintain.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id28" id="the-adapter-pattern" name="the-adapter-pattern">2.4&nbsp;&nbsp;&nbsp;The adapter pattern</a></h2>
<p>In a real application, the frontdesk object will need to handle
chores such as cancellations and updates.  In the current design, we
will need to pass the guest object to frontdesk every time we call
methods such as <cite>cancel_booking</cite> and <cite>update_booking</cite>.</p>
<!-- We can avoid this requirement by implementing FrontDesk such that the
guest object is set as an attribute:: -->
<p>We can avoid this requirement if we pass the guest object to
FrontDesk.__init__(), making it an attribute of the instance.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class FrontDeskNG(object):
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def book_room(self):
...         guest = self.guest
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
</blockquote>
<!-- include this bit at the front of the `Adapters` section when I get
the equivalent quote from the Patterns book to start the
`Interfaces` section

The solution we have reached is a common design pattern called,
`Adapter`.  The `Gang of Four` [#patternbook]_ give this as the
*intent* of Adapter::

 "Convert the interface of a class into another interface clients
 expect.  Adapter lets classes work together that couldn't otherwise
 because of incompatible interfaces." -->
<p>The solution we have reached is a well known pattern, the <em>adapter</em>.
In general, an adapter <em>contains</em> an <em>adaptee</em>:</p>
<pre class="literal-block">
&gt;&gt;&gt; class Adapter(object):
...
...     def __init__(self, adaptee):
...         self.adaptee = adaptee
</pre>
<p>This pattern will be useful in dealing with implementation details
which depend on considerations such as:</p>
<blockquote>
<ul class="simple">
<li>changing customer requirements</li>
<li>storage requirements (ZODB, RDBM, XML ...)</li>
<li>output requirements (HTML, PDF, plain text ...)</li>
<li>markup rendering (ReST, Markdown, Textile ...)</li>
</ul>
</blockquote>
<p>ZCA uses adapters and a <em>component registry</em> to provide the capability
to change implementation details of code via <em>configuration</em>.</p>
<p>As we will see in the section on ZCA adapters, the ability to
configure implementation details provides useful capability:</p>
<blockquote>
<ul class="simple">
<li>the ability to switch between implementations</li>
<li>the ability to add implementations as needed</li>
<li>increased re-use of both legacy and ZCA code</li>
</ul>
</blockquote>
<p>These capabilities lead to code that is flexible, scalable and
re-usable. There is a cost however, maintaining the component registry
adds a level of complexity to the application.  If an application will
never require these features, ZCA is unnecessary.</p>
<p>We are now ready to begin our study of the Zope Component
Architecture, beginning with interfaces.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id29" id="interfaces" name="interfaces">3&nbsp;&nbsp;&nbsp;Interfaces</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id30" id="id12" name="id12">3.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>The README.txt <a class="footnote-reference" href="#readmes" id="id13" name="id13">[11]</a> in path/to/zope/interface defines
interfaces like this:</p>
<pre class="literal-block">
Interfaces are objects that specify (document) the external behavior
of objects that &quot;provide&quot; them.  An interface specifies behavior
through:

- Informal documentation in a doc string

- Attribute definitions

- Invariants, which are conditions that must hold for objects that
  provide the interface
</pre>
<p>The classic software engineering book <cite>Design Patterns</cite> <a class="footnote-reference" href="#patternbook" id="id14" name="id14">[12]</a>
by the <cite>Gang of Four</cite> recommends that you &quot;Program to an interface,
not an implementation&quot;.  Defining a formal interface is helpful in
understanding a system.  Moreover, interfaces bring to you all the
benefits of ZCA.</p>
<table class="docutils footnote" frame="void" id="readmes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13" name="readmes">[11]</a></td><td>The Zope code tree is full of README.txt files which
offer wonderful documentation.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="patternbook" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14" name="patternbook">[12]</a></td><td><a class="reference" href="http://en.wikipedia.org/wiki/Design_Patterns">http://en.wikipedia.org/wiki/Design_Patterns</a></td></tr>
</tbody>
</table>
<p>An interface specifies the characteristics of an object, it's
behaviour, it's capabilities.  The interface describes <em>what</em> an
object can do, to learn <em>how</em>, you must look at the implementation.</p>
<p>Commonly used metaphors for interfaces are <cite>contract</cite> or <cite>blueprint</cite>,
the legal and architectural terms for a set of specifications.</p>
<p>In some modern programming languages: Java, C#, VB.NET etc, interfaces
are an explicit aspect of the language.  Since Python lacks
interfaces, ZCA implements them as a meta-class to inherit from.</p>
<p>Here is a classic <em>hello world</em> style example:</p>
<pre class="literal-block">
&gt;&gt;&gt; class Host(object):
...
...     def goodmorning(self, name):
...         &quot;&quot;&quot;Say good morning to guests&quot;&quot;&quot;
...
...         return &quot;Good morning, %s!&quot; % name
</pre>
<p>In the above class, you defined a <cite>goodmorning</cite> method.  If you call
the <cite>goodmorning</cite> method from an object created using this class, it
will return <cite>Good morning, ...!</cite></p>
<pre class="literal-block">
&gt;&gt;&gt; host = Host()
&gt;&gt;&gt; host.goodmorning('Jack')
'Good morning, Jack!'
</pre>
<p>Here <tt class="docutils literal"><span class="pre">host</span></tt> is the actual object your code uses.  If you want to
examine implementation details you need to access the class <tt class="docutils literal"><span class="pre">Host</span></tt>,
either via the source code or an API <a class="footnote-reference" href="#api" id="id15" name="id15">[13]</a> documentation tool.</p>
<table class="docutils footnote" frame="void" id="api" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15" name="api">[13]</a></td><td><a class="reference" href="http://en.wikipedia.org/wiki/Application_programming_interface">http://en.wikipedia.org/wiki/Application_programming_interface</a></td></tr>
</tbody>
</table>
<p>Now we will begin to use the ZCA interfaces.  For the class given
above you can specify the interface like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IHost(Interface):
...
...     def goodmorning(guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
</pre>
<p>As you can see, the interface inherits from zope.interface.Interface.
This use (abuse?) of Python's class statement is how ZCA defines an
interface.  The <tt class="docutils literal"><span class="pre">I</span></tt> prefix for the interface name is a useful
convention.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="declaring-interfaces" name="declaring-interfaces">3.2&nbsp;&nbsp;&nbsp;Declaring interfaces</a></h2>
<p>You have already seen how to declare an interface using
<tt class="docutils literal"><span class="pre">zope.interface</span></tt> in previous section.  This section will explain the
concepts in detail.</p>
<p>Consider this example interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute

&gt;&gt;&gt; class IHost(Interface):
...     &quot;&quot;&quot;A host object&quot;&quot;&quot;
...
...     name = Attribute(&quot;&quot;&quot;Name of host&quot;&quot;&quot;)
...
...     def goodmorning(guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
</pre>
<p>The interface, <tt class="docutils literal"><span class="pre">IHost</span></tt> has two attributes, <tt class="docutils literal"><span class="pre">name</span></tt> and
<tt class="docutils literal"><span class="pre">goodmorning</span></tt>.  Recall that, at least in Python, methods are also
attributes of classes.  The <tt class="docutils literal"><span class="pre">name</span></tt> attribute is defined using
<tt class="docutils literal"><span class="pre">zope.interface.Attribute</span></tt> class.  When you add the attribute
<tt class="docutils literal"><span class="pre">name</span></tt> to the <tt class="docutils literal"><span class="pre">IHost</span></tt> interface, you don't set an initial value.
The purpose of defining the attribute <tt class="docutils literal"><span class="pre">name</span></tt> here is merely to
indicate that any implementation of this interface will feature an
attribute named <tt class="docutils literal"><span class="pre">name</span></tt>.  In this case, you don't even say what type
of attribute it has to be!.  You can pass a documentation string as a
first argument to <tt class="docutils literal"><span class="pre">Attribute</span></tt>.</p>
<p>The other attribute, <tt class="docutils literal"><span class="pre">goodmorning</span></tt> is a method defined using a
function definition.  Note that <cite>self</cite> is not required in interfaces,
because <cite>self</cite> is an implementation detail of class.  For example, a
module can implement this interface.  If a module implement this
interface, there will be a <tt class="docutils literal"><span class="pre">name</span></tt> attribute and <tt class="docutils literal"><span class="pre">goodmorning</span></tt>
function defined.  And the <tt class="docutils literal"><span class="pre">goodmorning</span></tt> function will accept one
argument.</p>
<p>Now you will see how to connect <cite>interface-class-object</cite>.  So object
is the real living thing, objects are instances of classes.  And
interface is the actual definition of the object, so classes are just
the implementation details.  This is why you should program to an
interface and not to an implementation.</p>
<p>Now you should familiarize two more terms to understand other
concepts.  First one is <cite>provide</cite> and the other one is <cite>implement</cite>.
Object provides interfaces and classes implement interfaces.  In other
words, objects provide interfaces that their classes implement.  In
the above example <tt class="docutils literal"><span class="pre">host</span></tt> (object) provides <tt class="docutils literal"><span class="pre">IHost</span></tt> (interface) and
<tt class="docutils literal"><span class="pre">Host</span></tt> (class) implement <tt class="docutils literal"><span class="pre">IHost</span></tt> (interface).  One object can
provide more than one interface also one class can implement more than
one interface.  Objects can also provide interfaces directly, in
addition to what their classes implement.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Classes are the implementation details of objects.  In Python,
classes are callable objects, so why other callable objects can't
implement an interface.  Yes, it is possible.  For any <cite>callable
object</cite> you can declare that it produces objects that provide some
interfaces by saying that the <cite>callable object</cite> implements the
interfaces.  The <cite>callable objects</cite> are generally called as
<cite>factories</cite>.  Since functions are callable objects, a function can
be an <cite>implementer</cite> of an interface.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id32" id="implementing-interfaces" name="implementing-interfaces">3.3&nbsp;&nbsp;&nbsp;Implementing interfaces</a></h2>
<p>To declare a class implements a particular interface, use the function
<tt class="docutils literal"><span class="pre">zope.interface.implements</span></tt> in the class statement.</p>
<p>Consider this example, here <tt class="docutils literal"><span class="pre">Host</span></tt> implements <tt class="docutils literal"><span class="pre">IHost</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class Host(object):
...
...     implements(IHost)
...
...     name = u''
...
...     def goodmorning(self, guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
...
...         return &quot;Good morning, %s!&quot; % guest
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If you wonder how <tt class="docutils literal"><span class="pre">implements</span></tt> function works, refer the blog post
by James Henstridge
(<a class="reference" href="http://blogs.gnome.org/jamesh/2005/09/08/python-class-advisors/">http://blogs.gnome.org/jamesh/2005/09/08/python-class-advisors/</a>) .
In the adapter section, you will see an <tt class="docutils literal"><span class="pre">adapts</span></tt> function, it is
also working similarly.</p>
</div>
<p>Since <tt class="docutils literal"><span class="pre">Host</span></tt> implements <tt class="docutils literal"><span class="pre">IHost</span></tt>, instances of <tt class="docutils literal"><span class="pre">Host</span></tt> provides
<tt class="docutils literal"><span class="pre">IHost</span></tt>.  There are some utility methods to introspect the
declarations.  The declaration can write outside the class also.  If
you don't write <tt class="docutils literal"><span class="pre">interface.implements(IHost)</span></tt> in the above example,
then after defining the class statement, you can write like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import classImplements
&gt;&gt;&gt; classImplements(Host, IHost)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="example-revisited" name="example-revisited">3.4&nbsp;&nbsp;&nbsp;Example revisited</a></h2>
<p>Now, return to the example application.  Here you will see how to
define the interface of the frontdesk object:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...
</pre>
<p>Here, first you imported <tt class="docutils literal"><span class="pre">Interface</span></tt> class from <tt class="docutils literal"><span class="pre">zope.interface</span></tt>
module.  If you define a subclass of this <tt class="docutils literal"><span class="pre">Interface</span></tt> class, it will
be an interface from Zope component architecture point of view.  An
interface can be implemented, as you already noted, in a class or any
other callable object.</p>
<p>The frontdesk interface defined here is <tt class="docutils literal"><span class="pre">IDesk</span></tt>.  The
documentation string for interface gives an idea about the object.  By
defining a method in the interface, you made a contract for the
component, that there will be a method with same name available.  For
the method definition interface, the first argument should not be
<cite>self</cite>, because an interface will never be instantiated nor will its
methods ever be called.  Instead, the interface class merely documents
what methods and attributes should appear in any normal class that
claims to implement it, and the <cite>self</cite> parameter is an implementation
detail which doesn't need to be documented.</p>
<p>As you know, an interface can also specify normal attributes:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute

&gt;&gt;&gt; class IGuest(Interface):
...
...     name = Attribute(&quot;Name of guest&quot;)
...     place = Attribute(&quot;Place of guest&quot;)
</pre>
<p>In this interface, guest object has two attributes specified with
documentation.  An interface can also specify both attributes and
methods together.  An interface can be implemented in a class, module
or any other objects.  For example a function can dynamically create
the component and return, in this case the function is an implementer
for the interface.</p>
<p>Now you know what is an interface and how to define and use it.  In
the next chapter you can see how an interface is used to define an
adapter component.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="marker-interfaces" name="marker-interfaces">3.5&nbsp;&nbsp;&nbsp;Marker interfaces</a></h2>
<p>An interface can be used to declare that a particular object belongs
to a special type.  An interface without any attribute or method is
called <cite>marker interface</cite>.</p>
<p>Here is a <cite>marker interface</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class ISpecialGuest(Interface):
...     &quot;&quot;&quot;A special guest&quot;&quot;&quot;
</pre>
<p>This interface can be used to declare an object is a special guest.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id35" id="invariants" name="invariants">3.6&nbsp;&nbsp;&nbsp;Invariants</a></h2>
<p>Sometimes you will be required to use some rule for your component
which involve one or more normal attributes.  These kind of rule is
called <cite>invariants</cite>.  You can use <tt class="docutils literal"><span class="pre">zope.interface.invariant</span></tt> for
setting <cite>invariants</cite> for your objects in their interface.</p>
<p>Consider a simple example, there is a <cite>person</cite> object.  A person
object has <cite>name</cite>, <cite>email</cite> and <cite>phone</cite> attributes.  How do you
implement a validation rule that says either email or phone have to
exist, but not necessarily both.</p>
<p>First you have to make a callable object, either a simple function or
callable instance of a class like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; def contacts_invariant(obj):
...
...     if not (obj.email or obj.phone):
...         raise Exception(
...             &quot;At least one contact info is required&quot;)
</pre>
<p>Then define the <cite>person</cite> object's interface like this.  Use the
<tt class="docutils literal"><span class="pre">zope.interface.invariant</span></tt> function to set the invariant:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import invariant

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name&quot;)
...     email = Attribute(&quot;Email Address&quot;)
...     phone = Attribute(&quot;Phone Number&quot;)
...
...     invariant(contacts_invariant)
</pre>
<p>Now use <cite>validateInvariants</cite> method of the interface to validate:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class Person(object):
...     implements(IPerson)
...
...     name = None
...     email = None
...     phone = None

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.email = u&quot;jack&#64;some.address.com&quot;
&gt;&gt;&gt; IPerson.validateInvariants(jack)
&gt;&gt;&gt; jill = Person()
&gt;&gt;&gt; IPerson.validateInvariants(jill)
Traceback (most recent call last):
...
Exception: At least one contact info is required
</pre>
<p>As you can see <cite>jack</cite> object validated without raising any
exception. But <cite>jill</cite> object didn't validated the invariant
constraint, so it raised exception.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id36" id="adapters" name="adapters">4&nbsp;&nbsp;&nbsp;Adapters</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id37" id="implementation" name="implementation">4.1&nbsp;&nbsp;&nbsp;Implementation</a></h2>
<p>This section will describe adapters in detail.  Zope component
architecture, as you noted, helps to effectively use Python objects.
Adapter components are one of the basic components used by Zope
component architecture for effectively using Python objects.  Adapter
components are Python objects, but with well defined interface.</p>
<p>To declare a class is an adapter use <cite>adapts</cite> function defined in
<tt class="docutils literal"><span class="pre">zope.component</span></tt> package.  Here is a new <cite>FrontDeskNG</cite> adapter
with explicit interface declaration:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         guest = self.guest
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
<p>What you defined here is an <cite>adapter</cite> for <cite>IDesk</cite>, which adapts
<cite>IGuest</cite> object.  The <cite>IDesk</cite> interface is implemented by
<cite>FrontDeskNG</cite> class.  So, an instance of this class will provide
<cite>IDesk</cite> interface.</p>
<pre class="literal-block">
&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True
</pre>
<p>The <cite>FrontDeskNG</cite> is just one adapter you created, you can also
create other adapters which handles guest registration differently.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id38" id="registration" name="registration">4.2&nbsp;&nbsp;&nbsp;Registration</a></h2>
<p>To use this adapter component, you have to register this in a
component registry also known as site manager.  A site manager
normally resides in a site.  A site and site manager will be more
important when developing a Zope 3 application.  For now you only
required to bother about global site and global site manager ( or
component registry).  A global site manager will be in memory, but a
local site manager is persistent.</p>
<p>To register your component, first get the global site manager:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk, 'ng')
</pre>
<p>To get the global site manager, you have to call
<tt class="docutils literal"><span class="pre">getGlobalSiteManager</span></tt> function available in <tt class="docutils literal"><span class="pre">zope.component</span></tt>
package.  In fact, the global site manager is available as an
attribute (<tt class="docutils literal"><span class="pre">globalSiteManager</span></tt>) of <tt class="docutils literal"><span class="pre">zope.component</span></tt> package.  So,
you can directly use <tt class="docutils literal"><span class="pre">zope.component.globalSiteManager</span></tt> attribute.
To register the adapter in component, as you can see above, use
<tt class="docutils literal"><span class="pre">registerAdapter</span></tt> method of component registry.  The first argument
should be your adapter class/factory.  The second argument is a tuple
of <cite>adaptee</cite> objects, i.e, the object which you are adapting.  In this
example, you are adapting only <cite>IGuest</cite> object.  The third argument is
the interface implemented by the adapter component.  The fourth
argument is optional, that is the name of the particular adapter.
Since you gave a name for this adapter, this is a <cite>named adapter</cite>.  If
name is not given, it will default to an empty string ('').</p>
<p>In the above registration, you have given the adaptee interface and
interface to be provided by the adapter.  Since you have already given
these details in adapter implementation, it is not required to specify
again.  In fact, you could have done the registration like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG, name='ng')
</pre>
<p>There are some old API to do the registration, which you should avoid.
The old API functions starts with <cite>provide</cite>, eg: <tt class="docutils literal"><span class="pre">provideAdapter</span></tt>,
<tt class="docutils literal"><span class="pre">provideUtility</span></tt> etc.  While developing a Zope 3 application you can
use Zope configuration markup language (ZCML) for registration of
components.  In Zope 3, local components (persistent components) can
be registered from Zope Management Interface (ZMI) or you can do it
programmatically also.</p>
<p>You registered <cite>FrontDeskNG</cite> with a name <cite>ng</cite>.  Similarly you can
register other adapters with different names.  If a component is
registered without name, it will default to an empty string.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Local components are persistent components but global components are
in memory.  Global components will be registered based on the
configuration of application.  Local components are taken to memory
from database while starting the application.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id39" id="querying-adapter" name="querying-adapter">4.3&nbsp;&nbsp;&nbsp;Querying adapter</a></h2>
<p>Retrieving registered components from component registry is achieved
through two functions available in <tt class="docutils literal"><span class="pre">zope.component</span></tt> package.  One of
them is <tt class="docutils literal"><span class="pre">getAdapter</span></tt> and the other is <tt class="docutils literal"><span class="pre">queryAdapter</span></tt> .  Both
functions accepts same arguments.  The <tt class="docutils literal"><span class="pre">getAdapter</span></tt> will raise
<tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt> if component lookup fails on the other hand
<tt class="docutils literal"><span class="pre">queryAdapter</span></tt> will return <cite>None</cite>.</p>
<p>You can import the methods like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getAdapter
&gt;&gt;&gt; from zope.component import queryAdapter
</pre>
<p>In the previous section you have registered a component for guest
object (adaptee) which provides <cite>IDesk</cite> interface with name as
'ng'.  In the first section of this chapter, you have created a guest
object named <cite>jack</cite> .</p>
<p>This is how you can retrieve a component which adapts the interface of
<cite>jack</cite> object (<cite>IGuest</cite>) and provides <cite>IDesk</cite> interface also with
name as 'ng'.  Here both <tt class="docutils literal"><span class="pre">getAdapter</span></tt> and <tt class="docutils literal"><span class="pre">queryAdapter</span></tt> works
similarly:</p>
<pre class="literal-block">
&gt;&gt;&gt; getAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
&gt;&gt;&gt; queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
</pre>
<p>As you can see, the first argument should be adaptee then, the
interface which should be provided by component and last the name of
adapter component.</p>
<p>If you try to lookup the component with an name not used for
registration but for same adaptee and interface, the lookup will fail.
Here is how the two methods works in such a case:</p>
<pre class="literal-block">
&gt;&gt;&gt; getAdapter(jack, IDesk, 'not-exists') #doctest: +ELLIPSIS
Traceback (most recent call last):
...
ComponentLookupError: ...
&gt;&gt;&gt; reg = queryAdapter(jack,
...           IDesk, 'not-exists') #doctest: +ELLIPSIS
&gt;&gt;&gt; reg is None
True
</pre>
<p>As you can see above, <tt class="docutils literal"><span class="pre">getAdapter</span></tt> raised a <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt>
exception, but <tt class="docutils literal"><span class="pre">queryAdapter</span></tt> returned <cite>None</cite> when lookup failed.</p>
<p>The third argument, the name of registration, is optional.  If the
third argument is not given it will default to empty string ('').
Since there is no component registered with an empty string,
<tt class="docutils literal"><span class="pre">getAdapter</span></tt> will raise <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt> .  Similarly
<tt class="docutils literal"><span class="pre">queryAdapter</span></tt> will return <cite>None</cite>, see yourself how it works:</p>
<pre class="literal-block">
&gt;&gt;&gt; getAdapter(jack, IDesk) #doctest: +ELLIPSIS
Traceback (most recent call last):
...
ComponentLookupError: ...
&gt;&gt;&gt; reg = queryAdapter(jack, IDesk) #doctest: +ELLIPSIS
&gt;&gt;&gt; reg is None
True
</pre>
<p>In this section you have learned how to register a simple adapter and
how to retrieve it from component registry.  These kind of adapters is
called single adapter, because it adapts only one adaptee.  If an
adapter adapts more that one adaptee, then it is called multi
adapter.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id40" id="retrieving-adapter-using-interface" name="retrieving-adapter-using-interface">4.4&nbsp;&nbsp;&nbsp;Retrieving adapter using interface</a></h2>
<p>Adapters can be directly retrieved using interfaces, but it will only
work for non-named single adapters.  The first argument is the adaptee
and the second argument is a keyword argument.  If adapter lookup
fails, second argument will be returned.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; IDesk(jack, alternate='default-output')
'default-output'
</pre>
<p>Keyword name can be omitted:</p>
<pre class="doctest-block">
&gt;&gt;&gt; IDesk(jack, 'default-output')
'default-output'
</pre>
<p>If second argument is not given, it will raise <cite>TypeError</cite>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; IDesk(jack) #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
Traceback (most recent call last):
...
TypeError: ('Could not adapt',
  &lt;Guest object at ...&gt;,
  &lt;InterfaceClass __builtin__.IDesk&gt;)
</pre>
<p>Here <cite>FrontDeskNG</cite> is registered without name:</p>
<pre class="doctest-block">
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG)
</pre>
<p>Now the adapter lookup should succeed:</p>
<pre class="doctest-block">
&gt;&gt;&gt; IDesk(jack, 'default-output') #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
</pre>
</blockquote>
<p>For simple cases, you may use interface to get adapter components.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id41" id="adapter-pattern" name="adapter-pattern">4.5&nbsp;&nbsp;&nbsp;Adapter pattern</a></h2>
<p>The adapter concept in Zope Component Architecture and the classic
<cite>adapter pattern</cite> as described in Design Patterns book are very
similar.  But the intent of ZCA adapter usage is more wider than the
<cite>adapter pattern</cite> itself.  The intent of <cite>adapter pattern</cite> is to
convert the interface of a class into another interface clients
expect.  This allows classes work together that couldn't otherwise
because of incompatible interfaces.  But in the <cite>motivation</cite> section
of Design Patterns book, GoF says: &quot;Often the adapter is responsible
for functionality the adapted class doesn't provide&quot;.  ZCA adapter has
more focus on adding functionality than creating a new interface for
an adapted object (adaptee).  ZCA adapter lets adapter classes extend
functionality by adding methods.  (It would be interesting to note
that <cite>Adapter</cite> was known as <cite>Feature</cite> in earlier stage of ZCA
design. ) <a class="footnote-reference" href="#feature" id="id16" name="id16">[14]</a></p>
<table class="docutils footnote" frame="void" id="feature" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16" name="feature">[14]</a></td><td>Thread discussing renaming of <cite>Feature</cite> to <cite>Adapter</cite>:
<a class="reference" href="http://mail.zope.org/pipermail/zope3-dev/2001-December/000008.html">http://mail.zope.org/pipermail/zope3-dev/2001-December/000008.html</a></td></tr>
</tbody>
</table>
<p>The above paragraph has a quote from Gang of Four book, it ends like
this: &quot; ...adapted class doesn't provide&quot;.  But in the next sentence I
used &quot;adapted object&quot; instead of &quot;adapted class&quot;, because GoF
describes about two variants of adapters based on implementations.
The first one is called <cite>class adapter</cite> and the other one is called
<cite>object adapter</cite>.  A class adapter uses multiple inheritance to adapt
one interface to another, on the other hand an object adapter relies
on object composition.  ZCA adapter is following object adapter
pattern, which use delegation as a mechanism for composition.  GoF's
second principle of object-oriented design goes like this: &quot;Favor
object composition over class inheritance&quot;.  For more details about
this subject please read Design Patterns book.</p>
<p>The major attraction of ZCA adapter are the explicit interface for
components and the component registry.  ZCA adapter components are
registered in component registry and looked up by client objects using
interface and name when required.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id42" id="utility" name="utility">5&nbsp;&nbsp;&nbsp;Utility</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id43" id="id17" name="id17">5.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>Now you know the concept of interface, adapter and component registry.
Sometimes it would be useful to register an object which is not
adapting anything.  Database connection, XML parser, object returning
unique Ids etc. are examples of these kinds of objects.  These kind of
components provided by the ZCA are called <tt class="docutils literal"><span class="pre">utility</span></tt> components.</p>
<p>Utilities are just objects that provide an interface and that are
looked up by an interface and a name.  This approach creates a global
registry by which instances can be registered and accessed by
different parts of your application, with no need to pass the
instances around as parameters.</p>
<p>You need not to register all component instances like this.  Only
register components which you want to make replaceable.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id44" id="simple-utility" name="simple-utility">5.2&nbsp;&nbsp;&nbsp;Simple utility</a></h2>
<p>A utility can be registered with a name or without a name.  A utility
registered with a name is called named utility, which you will see in
the next section.  Before implementing the utility, as usual, define
its interface.  Here is a <cite>greeter</cite> interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...
...     def greet(name):
...         &quot;&quot;&quot;Say hello&quot;&quot;&quot;
</pre>
<p>Like an adapter a utility may have more than one implementation.  Here
is a possible implementation of the above interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name
</pre>
<p>The actual utility will be an instance of this class.  To use this
utility, you have to register it, later you can query it using the ZCA
API.  You can register an instance of this class (<cite>utility</cite>) using
<tt class="docutils literal"><span class="pre">registerUtility</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)
</pre>
<p>In this example you registered the utility as providing the <cite>IGreeter</cite>
interface.  You can look the interface up with either <cite>queryUtility</cite>
or <cite>getUtility</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import queryUtility
&gt;&gt;&gt; from zope.component import getUtility

&gt;&gt;&gt; queryUtility(IGreeter).greet('Jack')
'Hello Jack'

&gt;&gt;&gt; getUtility(IGreeter).greet('Jack')
'Hello Jack'
</pre>
<p>As you can see, adapters are normally classes, but utilities are
normally instances of classes.  Only once you are creating the
instance of a utility class, but adapter instances are dynamically
created whenever you query for it.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="named-utility" name="named-utility">5.3&nbsp;&nbsp;&nbsp;Named utility</a></h2>
<p>When registering a utility component, like adapter, you can use a
name.  As mentioned in the previous section, a utility registered with
a particular name is called named utility.</p>
<p>This is how you can register the <cite>greeter</cite> utility with a name:</p>
<pre class="literal-block">
&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter, 'new')
</pre>
<p>In this example you registered the utility with a name as providing
the <cite>IGreeter</cite> interface.  You can look up the interface with either
<cite>queryUtility</cite> or <cite>getUtility</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import queryUtility
&gt;&gt;&gt; from zope.component import getUtility

&gt;&gt;&gt; queryUtility(IGreeter, 'new').greet('Jill')
'Hello Jill'

&gt;&gt;&gt; getUtility(IGreeter, 'new').greet('Jill')
'Hello Jill'
</pre>
<p>As you can see here, while querying you have to use the <cite>name</cite> as
second argument.</p>
<p>Calling <cite>getUtility</cite> function without a name (second argument) is
equivalent to calling with an empty string as the name.  Because, the
default value for second (keyword) argument is an empty string.  Then,
component lookup mechanism will try to find the component with name as
empty string, and it will fail.  When component lookup fails it will
raise <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt> exception.  Remember, it will not
return some random component registered with some other name.  The
adapter look up functions, <cite>getAdapter</cite> and <cite>queryAdapter</cite> also works
similarly.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id46" id="factory" name="factory">5.4&nbsp;&nbsp;&nbsp;Factory</a></h2>
<p>A <tt class="docutils literal"><span class="pre">Factory</span></tt> is a utility component which provides <tt class="docutils literal"><span class="pre">IFactory</span></tt>
interface.</p>
<p>To create a factory, first define the interface of the object:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;
</pre>
<p>Here is fake implementation of <cite>IDatabase</cite> interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;
</pre>
<p>You can create a factory using <tt class="docutils literal"><span class="pre">zope.component.factory.Factory</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')
</pre>
<p>Now you can register it like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')
</pre>
<p>To use the factory, you may do it like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import queryUtility
&gt;&gt;&gt; queryUtility(IFactory, 'fakedb')() #doctest: +ELLIPSIS
&lt;FakeDb object at ...&gt;
</pre>
<p>There is a shortcut to use factory:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import createObject
&gt;&gt;&gt; createObject('fakedb') #doctest: +ELLIPSIS
&lt;FakeDb object at ...&gt;
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id47" id="advanced-adapters" name="advanced-adapters">6&nbsp;&nbsp;&nbsp;Advanced adapters</a></h1>
<p>This chapter discuss some advanced adapters like multi adapter,
subscription adapter and handler.</p>
<div class="section">
<h2><a class="toc-backref" href="#id48" id="multi-adapter" name="multi-adapter">6.1&nbsp;&nbsp;&nbsp;Multi adapter</a></h2>
<p>A simple adapter normally adapts only one object, but an adapter may
adapt more than one object.  If an adapter adapts more than one
objects, it is called <cite>multi-adapter</cite>.</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class IAdapteeOne(Interface):
...     pass

&gt;&gt;&gt; class IAdapteeTwo(Interface):
...     pass

&gt;&gt;&gt; class IFunctionality(Interface):
...     pass

&gt;&gt;&gt; class MyFunctionality(object):
...     implements(IFunctionality)
...     adapts(IAdapteeOne, IAdapteeTwo)
...
...     def __init__(self, one, two):
...         self.one = one
...         self.two = two

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(MyFunctionality)

&gt;&gt;&gt; class One(object):
...     implements(IAdapteeOne)

&gt;&gt;&gt; class Two(object):
...     implements(IAdapteeTwo)

&gt;&gt;&gt; one = One()
&gt;&gt;&gt; two = Two()

&gt;&gt;&gt; from zope.component import getMultiAdapter

&gt;&gt;&gt; getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
&lt;MyFunctionality object at ...&gt;

&gt;&gt;&gt; myfunctionality = getMultiAdapter((one,two), IFunctionality)
&gt;&gt;&gt; myfunctionality.one #doctest: +ELLIPSIS
&lt;One object at ...&gt;
&gt;&gt;&gt; myfunctionality.two #doctest: +ELLIPSIS
&lt;Two object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id49" id="subscription-adapter" name="subscription-adapter">6.2&nbsp;&nbsp;&nbsp;Subscription adapter</a></h2>
<p>Unlike regular adapters, subscription adapters are used when we want
all of the adapters that adapt an object to a particular interface.
Subscription adapter is also known as <cite>subscriber</cite>.</p>
<p>Consider a validation problem.  We have objects and we want to assess
whether they meet some sort of standards.  We define a validation
interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;
</pre>
<p>Perhaps we have documents:</p>
<pre class="literal-block">
&gt;&gt;&gt; class IDocument(Interface):
...
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...
...     implements(IDocument)
...
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body
</pre>
<p>Now, we may want to specify various validation rules for
documents. For example, we might require that the summary be a single
line:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class SingleLineSummary:
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if '\n' in self.doc.summary:
...             return 'Summary should only have one line'
...         else:
...             return ''
</pre>
<p>Or we might require the body to be at least 1000 characters in length:</p>
<pre class="literal-block">
&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''
</pre>
<p>We can register these as subscription adapters:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(SingleLineSummary)
&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)
</pre>
<p>We can then use the subscribers to validate objects:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import subscribers

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line', 'too short']

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot; * 1000)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line']

&gt;&gt;&gt; doc = Document(&quot;A Document&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['too short']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="handler" name="handler">6.3&nbsp;&nbsp;&nbsp;Handler</a></h2>
<p>Handlers are subscription adapter factories that don't produce
anything.  They do all of their work when called.  Handlers are
typically used to handle events.  Handlers are also known as event
subscribers or event subscription adapters.</p>
<p>Event subscribers are different from other subscription adapters in
that the caller of event subscribers doesn't expect to interact with
them in any direct way.  For example, an event publisher doesn't
expect to get any return value.  Because subscribers don't need to
provide an API to their callers, it is more natural to define them
with functions, rather than classes.  For example, in a
document-management system, we might want to record creation times for
documents:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()
</pre>
<p>In this example, we have a function that takes an event and performs
some processing.  It doesn't actually return anything.  This is a
special case of a subscription adapter that adapts an event to
nothing.  All of the work is done when the adapter &quot;factory&quot; is
called.  We call subscribers that don't actually create anything
&quot;handlers&quot;.  There are special APIs for registering and calling them.</p>
<p>To register the subscriber above, we define a document-created event:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc
</pre>
<p>We'll also change our handler definition to:</p>
<pre class="literal-block">
&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()
</pre>
<p>This marks the handler as an adapter of <cite>IDocumentCreated</cite> events.</p>
<p>Now we'll register the handler:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated)
</pre>
<p>Now, we can create an event and use the <cite>handle</cite> function to call
handlers registered for the event:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentCreated(doc))
&gt;&gt;&gt; doc.created.__class__.__name__
'datetime'
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id51" id="zca-usage-in-zope" name="zca-usage-in-zope">7&nbsp;&nbsp;&nbsp;ZCA usage in Zope</a></h1>
<p>Zope Component Architecture is used in both Zope 3 and Zope 2.  This
chapter will go through usage of the ZCA in Zope.</p>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="zcml" name="zcml">7.1&nbsp;&nbsp;&nbsp;ZCML</a></h2>
<p>The <strong>Zope Configuration Markup Language (ZCML)</strong> is an XML based
configuration system for registration of components.  So, instead of
using Python API for registration, you can use ZCML.  But to use ZCML,
unfortunately, you will be required to install more dependency
packages.</p>
<p>To install these packages:</p>
<pre class="literal-block">
$ easy_install &quot;zope.component [zcml]&quot;
</pre>
<p>To register an adapter:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;adapter
    factory=&quot;.company.EmployeeSalary&quot;
    provides=&quot;.interfaces.ISalary&quot;
    for=&quot;.interfaces.IEmployee&quot;
    /&gt;
</pre>
<p>The <cite>provides</cite> and <cite>for</cite> attributes are optional, provided you have
declared it in the implementation:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;adapter
    factory=&quot;.company.EmployeeSalary&quot;
    /&gt;
</pre>
<p>If you want to register the component as named adapter, you can give a
<cite>name</cite> attribute:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;adapter
    factory=&quot;.company.EmployeeSalary&quot;
    name=&quot;salary&quot;
    /&gt;
</pre>
<p>Utilities are also registered similarly.</p>
<p>To register an utility:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    component=&quot;.database.connection&quot;
    provides=&quot;.interfaces.IConnection&quot;
    /&gt;
</pre>
<p>The <cite>provides</cite> attribute is optional, provided you have declared it in
the implementation:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    component=&quot;.database.connection&quot;
    /&gt;
</pre>
<p>If you want to register the component as named utility, you can give a
<cite>name</cite> attribute:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    component=&quot;.database.connection&quot;
    name=&quot;Database Connection&quot;
    /&gt;
</pre>
<p>Instead of directly using the component, you can also give a factory:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    factory=&quot;.database.Connection&quot;
    /&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id53" id="overrides" name="overrides">7.2&nbsp;&nbsp;&nbsp;Overrides</a></h2>
<p>When you register components using Python API (<tt class="docutils literal"><span class="pre">register*</span></tt> methods),
the last registered component will replace previously registered
component, if both are registered with same type of arguments.  For
example, consider this example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IA(Interface):
...     pass

&gt;&gt;&gt; class IP(Interface):
...     pass

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; class AP(object):
...
...     implements(IP)
...     adapts(IA)
...
...     def __init__(self, context):
...         self.context = context

&gt;&gt;&gt; class AP2(object):
...
...     implements(IP)
...     adapts(IA)
...
...     def __init__(self, context):
...         self.context = context

&gt;&gt;&gt; class A(object):
...
...     implements(IA)

&gt;&gt;&gt; a = A()
&gt;&gt;&gt; ap = AP(a)

&gt;&gt;&gt; gsm.registerAdapter(AP)

&gt;&gt;&gt; getAdapter(a, IP) #doctest: +ELLIPSIS
&lt;AP object at ...&gt;
</pre>
<p>If you register another adapter, the existing one will be replaced:</p>
<pre class="literal-block">
&gt;&gt;&gt; gsm.registerAdapter(AP2)

&gt;&gt;&gt; getAdapter(a, IP) #doctest: +ELLIPSIS
&lt;AP2 object at ...&gt;
</pre>
<p>But when registering components using ZCML, the second registration
will raise a conflict error.  This is a hint for you, otherwise there
is a chance for overriding registration by mistake.  This may lead to
hard to track bugs in your system.  So, using ZCML is a win for the
application.</p>
<p>Sometimes you will be required to override existing registration.
ZCML provides <tt class="docutils literal"><span class="pre">includeOverrides</span></tt> directive for this.  Using this,
you can write your overrides in a separate file:</p>
<pre class="literal-block">
&lt;includeOverrides file=&quot;overrides.zcml&quot; /&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id54" id="namechooser" name="namechooser">7.3&nbsp;&nbsp;&nbsp;NameChooser</a></h2>
<p>Location: <cite>zope.app.container.contained.NameChooser</cite></p>
<p>This is an adapter for choosing a unique name for an object inside a
container.</p>
<p>The registration of adapter is like this:</p>
<pre class="literal-block">
&lt;adapter
    provides=&quot;.interfaces.INameChooser&quot;
    for=&quot;zope.app.container.interfaces.IWriteContainer&quot;
    factory=&quot;.contained.NameChooser&quot;
    /&gt;
</pre>
<p>From the registration, you can see that the adaptee is a
<tt class="docutils literal"><span class="pre">IWriteContainer</span></tt> and the adapter provides <tt class="docutils literal"><span class="pre">INameChooser</span></tt>.</p>
<p>This adapter provides a very convenient functionality for Zope
programmers.  The main implementations of <tt class="docutils literal"><span class="pre">IWriteContainer</span></tt> in
Zope 3 are <tt class="docutils literal"><span class="pre">zope.app.container.BTreeContainer</span></tt> and
<tt class="docutils literal"><span class="pre">zope.app.folder.Folder</span></tt>.  Normally you will be inheriting from
these implementations for creating your own container classes.
Suppose there is no interface called <tt class="docutils literal"><span class="pre">INameChooser</span></tt> and
adapter, then you will be required to implement this functionality
for every implementations separately.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="locationphysicallylocatable" name="locationphysicallylocatable">7.4&nbsp;&nbsp;&nbsp;LocationPhysicallyLocatable</a></h2>
<p>Location:
<tt class="docutils literal"><span class="pre">zope.location.traversing.LocationPhysicallyLocatable</span></tt></p>
<p>This adapter is frequently used in Zope 3 applications, but
normally it is called through an API in <tt class="docutils literal"><span class="pre">zope.traversing.api</span></tt>.
(Some old code even use <tt class="docutils literal"><span class="pre">zope.app.zapi</span></tt> functions, which is
again one more indirection)</p>
<p>The registration of adapter is like this:</p>
<pre class="literal-block">
&lt;adapter
    factory=&quot;zope.location.traversing.LocationPhysicallyLocatable&quot;
    /&gt;
</pre>
<p>The interface provided and adaptee interface is given in the
implementation.</p>
<p>Here is the beginning of implementation:</p>
<pre class="literal-block">
class LocationPhysicallyLocatable(object):
    &quot;&quot;&quot;Provide location information for location objects
    &quot;&quot;&quot;
    zope.component.adapts(ILocation)
    zope.interface.implements(IPhysicallyLocatable)
    ...
</pre>
<p>Normally, almost all persistent objects in Zope 3 application
will be providing the <tt class="docutils literal"><span class="pre">ILocation</span></tt> interface.  This interface
has only two attribute, <tt class="docutils literal"><span class="pre">__parent__</span></tt> and <tt class="docutils literal"><span class="pre">__name__</span></tt>.  The
<tt class="docutils literal"><span class="pre">__parent__</span></tt> is the parent in the location hierarchy.  And
<tt class="docutils literal"><span class="pre">__name__</span></tt> is the name within the parent.</p>
<p>The <tt class="docutils literal"><span class="pre">IPhysicallyLocatable</span></tt> interface has four methods:
<tt class="docutils literal"><span class="pre">getRoot</span></tt>, <tt class="docutils literal"><span class="pre">getPath</span></tt>, <tt class="docutils literal"><span class="pre">getName</span></tt>, and <tt class="docutils literal"><span class="pre">getNearestSite</span></tt>.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">getRoot</span></tt> function will return the physical root object.</li>
<li><tt class="docutils literal"><span class="pre">getPath</span></tt> return the physical path to the object as a
string.</li>
<li><tt class="docutils literal"><span class="pre">getName</span></tt> return the last segment of the physical path.</li>
<li><tt class="docutils literal"><span class="pre">getNearestSite</span></tt> return the site the object is contained
in.  If the object is a site, the object itself is returned.</li>
</ul>
</blockquote>
<p>If you learn Zope 3, you can see that these are the important
things which you required very often.  To understand the beauty
of this system, you must see how Zope 2 actually get the physical
root object and how it is implemented.  There is a method called
<tt class="docutils literal"><span class="pre">getPhysicalRoot</span></tt> virtually for all container objects.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id56" id="defaultsized" name="defaultsized">7.5&nbsp;&nbsp;&nbsp;DefaultSized</a></h2>
<p>Location: <tt class="docutils literal"><span class="pre">zope.size.DefaultSized</span></tt></p>
<p>This adapter is just a default implementation of <tt class="docutils literal"><span class="pre">ISized</span></tt> interface.
This adapter is registered for all kind of objects.  If you want to
register this adapter for a particular interface, then you have to
override this registration for your implementation.</p>
<p>The registration of adapter is like this:</p>
<pre class="literal-block">
&lt;adapter
    for=&quot;*&quot;
    factory=&quot;zope.size.DefaultSized&quot;
    provides=&quot;zope.size.interfaces.ISized&quot;
    permission=&quot;zope.View&quot;
    /&gt;
</pre>
<p>As you can see, the adaptee interface is <cite>*</cite>, so it can adapt any kind
of objects.</p>
<p>The <tt class="docutils literal"><span class="pre">ISized</span></tt> is a simple interface with two method contracts:</p>
<pre class="literal-block">
class ISized(Interface):

    def sizeForSorting():
        &quot;&quot;&quot;Returns a tuple (basic_unit, amount)

        Used for sorting among different kinds of sized objects.
        'amount' need only be sortable among things that share the
        same basic unit.&quot;&quot;&quot;

    def sizeForDisplay():
        &quot;&quot;&quot;Returns a string giving the size.
        &quot;&quot;&quot;
</pre>
<p>You can see another <tt class="docutils literal"><span class="pre">ISized</span></tt> adapter registered for <tt class="docutils literal"><span class="pre">IZPTPage</span></tt> in
<tt class="docutils literal"><span class="pre">zope.app.zptpage</span></tt> package.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id57" id="zopeversionutility" name="zopeversionutility">7.6&nbsp;&nbsp;&nbsp;ZopeVersionUtility</a></h2>
<p>Location: <tt class="docutils literal"><span class="pre">zope.app.applicationcontrol.ZopeVersionUtility</span></tt></p>
<p>This utility gives version of the running Zope.</p>
<p>The registration goes like this:</p>
<pre class="literal-block">
&lt;utility
    component=&quot;.zopeversion.ZopeVersionUtility&quot;
    provides=&quot;.interfaces.IZopeVersion&quot; /&gt;
</pre>
<p>The interface provided, <tt class="docutils literal"><span class="pre">IZopeVersion</span></tt>, has only one method named
<tt class="docutils literal"><span class="pre">getZopeVersion</span></tt>.  This method return a string containing the Zope
version (possibly including SVN information).</p>
<p>The default implementation, <tt class="docutils literal"><span class="pre">ZopeVersionUtility</span></tt>, get version info
from a file <tt class="docutils literal"><span class="pre">version.txt</span></tt> in <cite>zope/app</cite> directory.  If Zope is
running from subversion checkout, it will show the latest revision
number.  If none of the above works it will set it to:
<cite>Development/Unknown</cite>.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id58" id="case-study" name="case-study">8&nbsp;&nbsp;&nbsp;Case study</a></h1>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This chapter is not yet completed.  Please send your suggestions !</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id59" id="id18" name="id18">8.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>This chapter demonstrates creating a desktop application using PyGTK
GUI library and the ZCA.  This application also use two different
kinds of data persistence mechanisms, one object database (ZODB) &amp; and
another relational database (SQLite).  However, practically, only one
storage can be used for a particular installation.  The reason for
using two different persistence mechanisms is to demonstrate how to
use the ZCA to glue components.  Majority of the code in this
application is related to PyGTK.</p>
<p>As the application grows you may use the ZCA components wherever you
want pluggability or extensibility.  Use plain Python objects directly
where you do not required pluggability or extensibility.</p>
<p>There is no difference in using ZCA for web or desktop or any other
kind of application or framework.  It is better to follow a
convention for the location from where you are going to register
components.  This application use a convention, which can be extended
by putting registration of similar components in separate modules and
later import them from main registration module.  In this application
the main component registration module is <cite>register.py</cite>.</p>
<p>Source code of this application can be downloaded from:
<a class="reference" href="http://www.muthukadan.net/downloads/zcalib.tar.bz2">http://www.muthukadan.net/downloads/zcalib.tar.bz2</a></p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id60" id="use-cases" name="use-cases">8.2&nbsp;&nbsp;&nbsp;Use cases</a></h2>
<p>The application we are going to discuss here is a library management
system with minimal features.  The requirements can be summarized like
this:</p>
<blockquote>
<ul class="simple">
<li>Add members with a unique number and name.</li>
<li>Add books with barcode, author &amp; title</li>
<li>Issue books</li>
<li>Return books</li>
</ul>
</blockquote>
<p>The application can be designed in such a way that major features can
be accessed from a single window.  The main window for accessing all
these features can be designed like this:</p>
<div align="center" class="align-center"><img alt="mainwindow.png" class="align-center" src="mainwindow.png" /></div>
<p>From member window, user should be able to manage members.  So, it
should be possible to <em>add</em>, <em>update</em> and <em>delete</em> members as shown
in the below picture:</p>
<div align="center" class="align-center"><img alt="memberwindow.png" class="align-center" src="memberwindow.png" /></div>
<p>Similar to member window, the catalog window allows user to <em>add</em>,
<em>edit</em> and <em>delete</em> books:</p>
<div align="center" class="align-center"><img alt="catalogwindow.png" class="align-center" src="catalogwindow.png" /></div>
<p>The circulation window should have the facility for issuing and
returning books:</p>
<div align="center" class="align-center"><img alt="circulationwindow.png" class="align-center" src="circulationwindow.png" /></div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id61" id="overview-of-pygtk-code" name="overview-of-pygtk-code">8.3&nbsp;&nbsp;&nbsp;Overview of PyGTK code</a></h2>
<p>As you can see in the code, most of the code are related to PyGTK.
The code structure is very similar for different windows.  The windows
of this application are designed using Glade GUI builder.  You should
give proper names for widgets you are going to use from code.  In the
main window, all menu entries has names like: circulation, catalog,
member, quit &amp; about.</p>
<p>The <tt class="docutils literal"><span class="pre">gtk.glade.XML</span></tt> class is used to parse glade file, this will
create GUI widget objects.  This is how to parse and access objects:</p>
<pre class="literal-block">
import gtk.glade
xmlobj = gtk.glade.XML('/path/to/file.glade')
widget = xmlobj.get_widget('widget_name')
</pre>
<p>In the mainwindow.py, you can see code like this:</p>
<pre class="literal-block">
curdir = os.path.abspath(os.path.dirname(__file__))
xml = os.path.join(curdir, 'glade', 'mainwindow.glade')
xmlobj = gtk.glade.XML(xml)

self.mainwindow = xmlobj.get_widget('mainwindow')
</pre>
<p>The name of main window widget is <cite>mainwindow</cite>.  Similarly, other
widgets are retrieved like this:</p>
<pre class="literal-block">
circulation = xmlobj.get_widget('circulation')
member = xmlobj.get_widget('member')
quit = xmlobj.get_widget('quit')
catalog = xmlobj.get_widget('catalog')
about = xmlobj.get_widget('about')
</pre>
<p>Then, these widgets are connected for some events:</p>
<pre class="literal-block">
self.mainwindow.connect('delete_event', self.delete_event)
quit.connect('activate', self.delete_event)
circulation.connect('activate', self.on_circulation_activate)
member.connect('activate', self.on_member_activate)
catalog.connect('activate', self.on_catalog_activate)
about.connect('activate', self.on_about_activate)
</pre>
<p>The <cite>delete_event</cite> is the event when the window is closing using the
window close button.  The <cite>activate</cite> event is emitted when the menu is
selected.  The widgets are connected to some callback functions for
some events.</p>
<p>You can see from the above code that, main window is connected to
<cite>on_delete_event</cite> method for <cite>delete_event</cite>.  The <cite>quit</cite> widget is
also connected to same method for <cite>activate</cite> event:</p>
<pre class="literal-block">
def on_delete_event(self, *args):
    gtk.main_quit()
</pre>
<p>The callback function just call <cite>main_quit</cite> function</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id62" id="the-code" name="the-code">8.4&nbsp;&nbsp;&nbsp;The code</a></h2>
<p>This is the <cite>zcalib.py</cite>:</p>
<pre class="literal-block">
import registry
import mainwindow

if __name__ == '__main__':
    registry.initialize()
    try:
        mainwindow.main()
    except KeyboardInterrupt:
        import sys
        sys.exit(1)
</pre>
<p>Here, two modules are imported <cite>registry</cite> and <cite>mainwindow</cite>.  Then,
registry is initialized and mainwindow's <cite>main</cite> function is called.
If user is trying to exit application using <cite>Ctrl+C</cite>, system will exit
normally, that's why we catched <cite>KeyboardInterrupt</cite> exception.</p>
<p>This is the <cite>registry.py</cite>:</p>
<pre class="literal-block">
import sys
from zope.component import getGlobalSiteManager

from interfaces import IMember
from interfaces import IBook
from interfaces import ICirculation
from interfaces import IDbOperation


def initialize_rdb():
    from interfaces import IRelationalDatabase
    from relationaldatabase import RelationalDatabase
    from member import MemberRDbOperation
    from catalog import BookRDbOperation
    from circulation import CirculationRDbOperation

    gsm = getGlobalSiteManager()
    db = RelationalDatabase()
    gsm.registerUtility(db, IRelationalDatabase)

    gsm.registerAdapter(MemberRDbOperation,
                        (IMember,),
                        IDbOperation)

    gsm.registerAdapter(BookRDbOperation,
                        (IBook,),
                        IDbOperation)

    gsm.registerAdapter(CirculationRDbOperation,
                        (ICirculation,),
                        IDbOperation)

def initialize_odb():
    from interfaces import IObjectDatabase
    from objectdatabase import ObjectDatabase
    from member import MemberODbOperation
    from catalog import BookODbOperation
    from circulation import CirculationODbOperation

    gsm = getGlobalSiteManager()
    db = ObjectDatabase()
    gsm.registerUtility(db, IObjectDatabase)

    gsm.registerAdapter(MemberODbOperation,
                        (IMember,),
                        IDbOperation)

    gsm.registerAdapter(BookODbOperation,
                        (IBook,),
                        IDbOperation)

    gsm.registerAdapter(CirculationODbOperation,
                        (ICirculation,),
                        IDbOperation)

def check_use_relational_db():
    use_rdb = False
    try:
        arg = sys.argv[1]
        if arg == '-r':
            return True
    except IndexError:
        pass
    return use_rdb

def initialize():
    use_rdb = check_use_relational_db()
    if use_rdb:
        initialize_rdb()
    else:
        initialize_odb()
</pre>
<p>Look at the <cite>initialize</cite> function which we are calling from the main
module, <cite>zcalib.py</cite>.  The <cite>initialize</cite> function first check which db
to use, relational database (RDB) or object database (ODB) and this
checking is done at <cite>check_use_relational_db</cite> function.  If <cite>-r</cite>
option is given at command line, it will call <cite>initialize_rdb</cite>
otherwise, <cite>initialize_odb</cite>.  If the RDB function is called, it will
setup all components related to RDB.  On the other hand, if the ODB
function is called, it will setup all components related to ODB.</p>
<p>Here is the <cite>mainwindow.py</cite>:</p>
<pre class="literal-block">
import os
import gtk
import gtk.glade

from circulationwindow import circulationwindow
from catalogwindow import catalogwindow
from memberwindow import memberwindow

class MainWindow(object):

    def __init__(self):
        curdir = os.path.abspath(os.path.dirname(__file__))
        xml = os.path.join(curdir, 'glade', 'mainwindow.glade')
        xmlobj = gtk.glade.XML(xml)

        self.mainwindow = xmlobj.get_widget('mainwindow')
        circulation = xmlobj.get_widget('circulation')
        member = xmlobj.get_widget('member')
        quit = xmlobj.get_widget('quit')
        catalog = xmlobj.get_widget('catalog')
        about = xmlobj.get_widget('about')

        self.mainwindow.connect('delete_event', self.delete_event)
        quit.connect('activate', self.delete_event)

        circulation.connect('activate', self.on_circulation_activate)
        member.connect('activate', self.on_member_activate)
        catalog.connect('activate', self.on_catalog_activate)
        about.connect('activate', self.on_about_activate)

    def delete_event(self, *args):
        gtk.main_quit()

    def on_circulation_activate(self, *args):
        circulationwindow.show_all()

    def on_member_activate(self, *args):
        memberwindow.show_all()

    def on_catalog_activate(self, *args):
        catalogwindow.show_all()

    def on_about_activate(self, *args):
        pass

    def run(self):
        self.mainwindow.show_all()

def main():
    mainwindow = MainWindow()
    mainwindow.run()
    gtk.main()
</pre>
<p>The <cite>main</cite> function here creates an instance of <cite>MainWindow</cite> class,
which will initialize all widgets.</p>
<p>Here is the <cite>memberwindow.py</cite>:</p>
<pre class="literal-block">
import os
import gtk
import gtk.glade

from zope.component import getAdapter

from components import Member
from interfaces import IDbOperation


class MemberWindow(object):

    def __init__(self):
        curdir = os.path.abspath(os.path.dirname(__file__))
        xml = os.path.join(curdir, 'glade', 'memberwindow.glade')
        xmlobj = gtk.glade.XML(xml)

        self.memberwindow = xmlobj.get_widget('memberwindow')
        self.number = xmlobj.get_widget('number')
        self.name = xmlobj.get_widget('name')
        add = xmlobj.get_widget('add')
        update = xmlobj.get_widget('update')
        delete = xmlobj.get_widget('delete')
        close = xmlobj.get_widget('close')
        self.treeview = xmlobj.get_widget('treeview')

        self.memberwindow.connect('delete_event', self.on_delete_event)
        add.connect('clicked', self.on_add_clicked)
        update.connect('clicked', self.on_update_clicked)
        delete.connect('clicked', self.on_delete_clicked)
        close.connect('clicked', self.on_delete_event)

        self.initialize_list()

    def show_all(self):
        self.populate_list_store()
        self.memberwindow.show_all()

    def populate_list_store(self):
        self.list_store.clear()
        member = Member()
        memberdboperation = getAdapter(member, IDbOperation)
        members = memberdboperation.get()
        for member in members:
            number = member.number
            name = member.name
            self.list_store.append((member, number, name,))

    def on_delete_event(self, *args):
        self.memberwindow.hide()
        return True

    def initialize_list(self):
        self.list_store = gtk.ListStore(object, str, str)
        self.treeview.set_model(self.list_store)
        tvcolumn = gtk.TreeViewColumn('Member Number')
        self.treeview.append_column(tvcolumn)

        cell = gtk.CellRendererText()
        tvcolumn.pack_start(cell, True)
        tvcolumn.add_attribute(cell, 'text', 1)

        tvcolumn = gtk.TreeViewColumn('Member Name')
        self.treeview.append_column(tvcolumn)

        cell = gtk.CellRendererText()
        tvcolumn.pack_start(cell, True)
        tvcolumn.add_attribute(cell, 'text', 2)

    def on_add_clicked(self, *args):
        number = self.number.get_text()
        name = self.name.get_text()
        member = Member()
        member.number = number
        member.name = name
        self.add(member)
        self.list_store.append((member, number, name,))

    def add(self, member):
        memberdboperation = getAdapter(member, IDbOperation)
        memberdboperation.add()

    def on_update_clicked(self, *args):
        number = self.number.get_text()
        name = self.name.get_text()
        treeselection = self.treeview.get_selection()
        model, iter = treeselection.get_selected()
        if not iter:
            return
        member = self.list_store.get_value(iter, 0)
        member.number = number
        member.name = name
        self.update(member)
        self.list_store.set(iter, 1, number, 2, name)

    def update(self, member):
        memberdboperation = getAdapter(member, IDbOperation)
        memberdboperation.update()

    def on_delete_clicked(self, *args):
        treeselection = self.treeview.get_selection()
        model, iter = treeselection.get_selected()
        if not iter:
            return
        member = self.list_store.get_value(iter, 0)
        self.delete(member)
        self.list_store.remove(iter)

    def delete(self, member):
        memberdboperation = getAdapter(member, IDbOperation)
        memberdboperation.delete()

memberwindow = MemberWindow()
</pre>
<p>Here is the <cite>components.py</cite>:</p>
<pre class="literal-block">
from zope.interface import implements

from interfaces import IBook
from interfaces import IMember
from interfaces import ICirculation

class Book(object):

    implements(IBook)

    barcode = &quot;&quot;
    title = &quot;&quot;
    author = &quot;&quot;

class Member(object):

    implements(IMember)

    number = &quot;&quot;
    name = &quot;&quot;

class Circulation(object):

    implements(ICirculation)

    book = Book()
    member = Member()
</pre>
<p>Here is the <cite>interfaces.py</cite>:</p>
<pre class="literal-block">
from zope.interface import Interface
from zope.interface import Attribute


class IBook(Interface):

    barcode = Attribute(&quot;Barcode&quot;)
    author = Attribute(&quot;Author of book&quot;)
    title = Attribute(&quot;Title of book&quot;)


class IMember(Interface):

    number = Attribute(&quot;ID number&quot;)
    name = Attribute(&quot;Name of member&quot;)


class ICirculation(Interface):

    book = Attribute(&quot;A book&quot;)
    member = Attribute(&quot;A member&quot;)


class IRelationalDatabase(Interface):

    def commit():
        pass

    def rollback():
        pass

    def cursor():
        pass

    def get_next_id():
        pass


class IObjectDatabase(Interface):

    def commit():
        pass

    def rollback():
        pass

    def container():
        pass

    def get_next_id():
        pass


class IDbOperation(Interface):

    def get():
        pass

    def add():
        pass

    def update():
        pass

    def delete():
        pass
</pre>
<p>Here is the <cite>member.py</cite>:</p>
<pre class="literal-block">
from zope.interface import implements
from zope.component import getUtility
from zope.component import adapts

from components import Member

from interfaces import IRelationalDatabase
from interfaces import IObjectDatabase
from interfaces import IMember
from interfaces import IDbOperation


class MemberRDbOperation(object):

    implements(IDbOperation)
    adapts(IMember)

    def __init__(self, member):
        self.member = member

    def get(self):
        db = getUtility(IRelationalDatabase)
        cr = db.cursor()
        number = self.member.number
        if number:
            cr.execute(&quot;&quot;&quot;SELECT
                            id,
                            number,
                            name
                          FROM members
                          WHERE number = ?&quot;&quot;&quot;,
                       (number,))
        else:
            cr.execute(&quot;&quot;&quot;SELECT
                            id,
                            number,
                            name
                          FROM members&quot;&quot;&quot;)
        rst = cr.fetchall()
        cr.close()
        members = []
        for record in rst:
            id = record['id']
            number = record['number']
            name = record['name']
            member = Member()
            member.id = id
            member.number = number
            member.name = name
            members.append(member)
        return members

    def add(self):
        db = getUtility(IRelationalDatabase)
        cr = db.cursor()
        next_id = db.get_next_id(&quot;members&quot;)
        number = self.member.number
        name = self.member.name
        cr.execute(&quot;&quot;&quot;INSERT INTO members
                        (id, number, name)
                      VALUES (?, ?, ?)&quot;&quot;&quot;,
                   (next_id, number, name))
        cr.close()
        db.commit()
        self.member.id = next_id

    def update(self):
        db = getUtility(IRelationalDatabase)
        cr = db.cursor()
        number = self.member.number
        name = self.member.name
        id = self.member.id
        cr.execute(&quot;&quot;&quot;UPDATE members
                        SET
                           number = ?,
                           name = ?
                      WHERE id = ?&quot;&quot;&quot;,
                   (number, name, id))
        cr.close()
        db.commit()

    def delete(self):
        db = getUtility(IRelationalDatabase)
        cr = db.cursor()
        id = self.member.id
        cr.execute(&quot;&quot;&quot;DELETE FROM members
                      WHERE id = ?&quot;&quot;&quot;,
                   (id,))
        cr.close()
        db.commit()


class MemberODbOperation(object):

    implements(IDbOperation)
    adapts(IMember)

    def __init__(self, member):
        self.member = member

    def get(self):
        db = getUtility(IObjectDatabase)
        zcalibdb = db.container()
        members = zcalibdb['members']
        return members.values()

    def add(self):
        db = getUtility(IObjectDatabase)
        zcalibdb = db.container()
        members = zcalibdb['members']
        number = self.member.number
        if number in [x.number for x in members.values()]:
            db.rollback()
            raise Exception(&quot;Duplicate key&quot;)
        next_id = db.get_next_id('members')
        self.member.id = next_id
        members[next_id] = self.member
        db.commit()

    def update(self):
        db = getUtility(IObjectDatabase)
        zcalibdb = db.container()
        members = zcalibdb['members']
        id = self.member.id
        members[id] = self.member
        db.commit()

    def delete(self):
        db = getUtility(IObjectDatabase)
        zcalibdb = db.container()
        members = zcalibdb['members']
        id = self.member.id
        del members[id]
        db.commit()
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id63" id="pysqlite" name="pysqlite">8.5&nbsp;&nbsp;&nbsp;PySQLite</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id64" id="zodb" name="zodb">8.6&nbsp;&nbsp;&nbsp;ZODB</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id65" id="conclusions" name="conclusions">8.7&nbsp;&nbsp;&nbsp;Conclusions</a></h2>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id66" id="reference" name="reference">9&nbsp;&nbsp;&nbsp;Reference</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id67" id="adaptedby" name="adaptedby">9.1&nbsp;&nbsp;&nbsp;adaptedBy</a></h2>
<p>This function helps to find the adapted interfaces.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>adaptedBy(object)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts
&gt;&gt;&gt; from zope.component import adaptedBy

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest

&gt;&gt;&gt; adaptedBy(FrontDeskNG)
(&lt;InterfaceClass __builtin__.IGuest&gt;,)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id68" id="adapter" name="adapter">9.2&nbsp;&nbsp;&nbsp;adapter</a></h2>
<p>Adapters can be any callable object, you can use the <cite>adapter</cite>
decorator to declare that a callable object adapts some interfaces (or
classes)</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>adapter(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implementer
&gt;&gt;&gt; from zope.component import adapter
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IJob(Interface):
...     &quot;&quot;&quot;A job&quot;&quot;&quot;

&gt;&gt;&gt; class Job(object):
...     implements(IJob)

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name&quot;)
...     job = Attribute(&quot;Job&quot;)

&gt;&gt;&gt; class Person(object):
...     implements(IPerson)
...
...     name = None
...     job = None

&gt;&gt;&gt; &#64;implementer(IJob)
... &#64;adapter(IPerson)
... def personJob(person):
...     return person.job

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;
&gt;&gt;&gt; jack.job = Job()
&gt;&gt;&gt; personJob(jack) #doctest: +ELLIPSIS
&lt;Job object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id69" id="adapts" name="adapts">9.3&nbsp;&nbsp;&nbsp;adapts</a></h2>
<p>This function helps to declare adapter classes.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>adapts(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id70" id="alsoprovides" name="alsoprovides">9.4&nbsp;&nbsp;&nbsp;alsoProvides</a></h2>
<p>Declare interfaces declared directly for an object.  The arguments
after the object are one or more interfaces.  The interfaces given are
added to the interfaces previously declared for the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>alsoProvides(object, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import alsoProvides

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IDesk)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; alsoProvides(jack, IStudent)

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id71" id="attribute" name="attribute">9.5&nbsp;&nbsp;&nbsp;Attribute</a></h2>
<p>Using this class, you can define normal attributes in an interface.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>Attribute(name, doc='')</cite></li>
<li>See also: <a class="reference" href="#interface">Interface</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)
...     email = Attribute(&quot;Email Address&quot;)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id72" id="classimplements" name="classimplements">9.6&nbsp;&nbsp;&nbsp;classImplements</a></h2>
<p>Declare additional interfaces implemented for instances of a class.
The arguments after the class are one or more interfaces.  The
interfaces given are added to any interfaces previously declared.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>classImplements(cls, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import classImplements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IDesk)
...     name = u&quot;&quot;
...     college = u&quot;&quot;

&gt;&gt;&gt; classImplements(Person, IStudent)
&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id73" id="classimplementsonly" name="classimplementsonly">9.7&nbsp;&nbsp;&nbsp;classImplementsOnly</a></h2>
<p>Declare the only interfaces implemented by instances of a class.  The
arguments after the class are one or more interfaces.  The interfaces
given replace any previous declarations.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>classImplementsOnly(cls, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import classImplementsOnly

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     college = u&quot;&quot;

&gt;&gt;&gt; classImplementsOnly(Person, IStudent)
&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.college = &quot;New College&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
False
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id74" id="classprovides" name="classprovides">9.8&nbsp;&nbsp;&nbsp;classProvides</a></h2>
<p>Normally if a class implements a particular interface, the instance of
that class will provide the interface implemented by that class.  But
if you want a class to be provided by an interface, you can declare it
using <tt class="docutils literal"><span class="pre">classProvides</span></tt> function.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>classProvides(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import classProvides

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class Person(object):
...
...     classProvides(IPerson)
...     name = u&quot;Jack&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(Person)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id75" id="componentlookuperror" name="componentlookuperror">9.9&nbsp;&nbsp;&nbsp;ComponentLookupError</a></h2>
<p>This is the exception raised when a component lookup fails.</p>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; person = object()
&gt;&gt;&gt; getAdapter(person, IPerson, 'not-exists') #doctest: +ELLIPSIS
Traceback (most recent call last):
...
ComponentLookupError: ...
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id76" id="createobject" name="createobject">9.10&nbsp;&nbsp;&nbsp;createObject</a></h2>
<p>Create an object using a factory.</p>
<p>Finds the named factory in the current site and calls it with the
given arguments.  If a matching factory cannot be found raises
<tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt>.  Returns the created object.</p>
<p>A context keyword argument can be provided to cause the factory to be
looked up in a location other than the current site.  (Of course, this
means that it is impossible to pass a keyword argument named &quot;context&quot;
to the factory.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>createObject(factory_name, *args, **kwargs)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;

&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;

&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')

&gt;&gt;&gt; from zope.component import createObject
&gt;&gt;&gt; createObject('fakedb') #doctest: +ELLIPSIS
&lt;FakeDb object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id77" id="declaration" name="declaration">9.11&nbsp;&nbsp;&nbsp;Declaration</a></h2>
<p>Need not to use directly.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id78" id="directlyprovidedby" name="directlyprovidedby">9.12&nbsp;&nbsp;&nbsp;directlyProvidedBy</a></h2>
<p>This function will return the interfaces directly provided by the
given object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>directlyProvidedBy(object)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class ISmartPerson(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = u&quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; alsoProvides(jack, ISmartPerson, IStudent)

&gt;&gt;&gt; from zope.interface import directlyProvidedBy

&gt;&gt;&gt; jack_dp = directlyProvidedBy(jack)
&gt;&gt;&gt; IPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IStudent in jack_dp.interfaces()
True
&gt;&gt;&gt; ISmartPerson in jack_dp.interfaces()
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id79" id="directlyprovides" name="directlyprovides">9.13&nbsp;&nbsp;&nbsp;directlyProvides</a></h2>
<p>Declare interfaces declared directly for an object.  The arguments
after the object are one or more interfaces.  The interfaces given
replace interfaces previously declared for the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>directlyProvides(object, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class ISmartPerson(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = u&quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; alsoProvides(jack, ISmartPerson, IStudent)

&gt;&gt;&gt; from zope.interface import directlyProvidedBy

&gt;&gt;&gt; jack_dp = directlyProvidedBy(jack)
&gt;&gt;&gt; ISmartPerson in jack_dp.interfaces()
True
&gt;&gt;&gt; IPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IStudent in jack_dp.interfaces()
True
&gt;&gt;&gt; from zope.interface import providedBy

&gt;&gt;&gt; ISmartPerson in providedBy(jack)
True

&gt;&gt;&gt; from zope.interface import directlyProvides
&gt;&gt;&gt; directlyProvides(jack, IStudent)

&gt;&gt;&gt; jack_dp = directlyProvidedBy(jack)
&gt;&gt;&gt; ISmartPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IStudent in jack_dp.interfaces()
True

&gt;&gt;&gt; ISmartPerson in providedBy(jack)
False
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id80" id="getadapter" name="getadapter">9.14&nbsp;&nbsp;&nbsp;getAdapter</a></h2>
<p>Get a named adapter to an interface for an object.  Returns an adapter
that can adapt object to interface.  If a matching adapter cannot be
found, raises <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt> .</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>getAdapter(object, interface=Interface, name=u'', context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk, 'ng')

&gt;&gt;&gt; getAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id81" id="getadapterincontext" name="getadapterincontext">9.15&nbsp;&nbsp;&nbsp;getAdapterInContext</a></h2>
<p>Instead of this function, use <cite>context</cite> argument of <a class="reference" href="#getadapter">getAdapter</a>
function.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getAdapterInContext(object, interface, context)</cite></li>
<li>See also: <a class="reference" href="#queryadapterincontext">queryAdapterInContext</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.globalregistry import BaseGlobalComponents
&gt;&gt;&gt; from zope.component import IComponentLookup
&gt;&gt;&gt; sm = BaseGlobalComponents()

&gt;&gt;&gt; class Context(object):
...     def __init__(self, sm):
...         self.sm = sm
...     def __conform__(self, interface):
...         if interface.isOrExtends(IComponentLookup):
...             return self.sm

&gt;&gt;&gt; context = Context(sm)

&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; sm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk)

&gt;&gt;&gt; from zope.component import getAdapterInContext

&gt;&gt;&gt; getAdapterInContext(jack, IDesk, sm) #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id82" id="getadapters" name="getadapters">9.16&nbsp;&nbsp;&nbsp;getAdapters</a></h2>
<p>Look for all matching adapters to a provided interface for objects.
Return a list of adapters that match. If an adapter is named, only the
most specific adapter of a given name is returned.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getAdapters(objects, provided, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG, name='ng')

&gt;&gt;&gt; from zope.component import getAdapters
&gt;&gt;&gt; list(getAdapters((jack,), IDesk)) #doctest: +ELLIPSIS
[(u'ng', &lt;FrontDeskNG object at ...&gt;)]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id83" id="getallutilitiesregisteredfor" name="getallutilitiesregisteredfor">9.17&nbsp;&nbsp;&nbsp;getAllUtilitiesRegisteredFor</a></h2>
<p>Return all registered utilities for an interface.  This includes
overridden utilities.  The returned value is an iterable of utility
instances.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getAllUtilitiesRegisteredFor(interface)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import getAllUtilitiesRegisteredFor

&gt;&gt;&gt; getAllUtilitiesRegisteredFor(IGreeter) #doctest: +ELLIPSIS
[&lt;Greeter object at ...&gt;]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="getfactoriesfor" name="getfactoriesfor">9.18&nbsp;&nbsp;&nbsp;getFactoriesFor</a></h2>
<p>Return a tuple (name, factory) of registered factories that create
objects which implement the given interface.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getFactoriesFor(interface, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;

&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;

&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')

&gt;&gt;&gt; from zope.component import getFactoriesFor

&gt;&gt;&gt; list(getFactoriesFor(IDatabase))
[(u'fakedb', &lt;Factory for &lt;class 'FakeDb'&gt;&gt;)]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id85" id="getfactoryinterfaces" name="getfactoryinterfaces">9.19&nbsp;&nbsp;&nbsp;getFactoryInterfaces</a></h2>
<p>Get interfaces implemented by a factory.  Finds the factory of the
given name that is nearest to the context, and returns the interface
or interface tuple that object instances created by the named factory
will implement.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getFactoryInterfaces(name, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;

&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;

&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')

&gt;&gt;&gt; from zope.component import getFactoryInterfaces

&gt;&gt;&gt; getFactoryInterfaces('fakedb')
&lt;implementedBy __builtin__.FakeDb&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id86" id="getglobalsitemanager" name="getglobalsitemanager">9.20&nbsp;&nbsp;&nbsp;getGlobalSiteManager</a></h2>
<p>Return the global site manager.  This function should never fail and
always return an object that provides <cite>IGlobalSiteManager</cite></p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getGlobalSiteManager()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; from zope.component import globalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm is globalSiteManager
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id87" id="getmultiadapter" name="getmultiadapter">9.21&nbsp;&nbsp;&nbsp;getMultiAdapter</a></h2>
<p>Look for a multi-adapter to an interface for an objects.  Returns a
multi-adapter that can adapt objects to interface.  If a matching
adapter cannot be found, raises ComponentLookupError.  The name
consisting of an empty string is reserved for unnamed adapters. The
unnamed adapter methods will often call the named adapter methods with
an empty string for a name.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getMultiAdapter(objects, interface=Interface, name='',
context=None)</cite></li>
<li>See also: <a class="reference" href="#querymultiadapter">queryMultiAdapter</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class IAdapteeOne(Interface):
...     pass

&gt;&gt;&gt; class IAdapteeTwo(Interface):
...     pass

&gt;&gt;&gt; class IFunctionality(Interface):
...     pass

&gt;&gt;&gt; class MyFunctionality(object):
...     implements(IFunctionality)
...     adapts(IAdapteeOne, IAdapteeTwo)
...
...     def __init__(self, one, two):
...         self.one = one
...         self.two = two

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(MyFunctionality)

&gt;&gt;&gt; class One(object):
...     implements(IAdapteeOne)

&gt;&gt;&gt; class Two(object):
...     implements(IAdapteeTwo)

&gt;&gt;&gt; one = One()
&gt;&gt;&gt; two = Two()

&gt;&gt;&gt; from zope.component import getMultiAdapter

&gt;&gt;&gt; getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
&lt;MyFunctionality object at ...&gt;

&gt;&gt;&gt; myfunctionality = getMultiAdapter((one,two), IFunctionality)
&gt;&gt;&gt; myfunctionality.one #doctest: +ELLIPSIS
&lt;One object at ...&gt;
&gt;&gt;&gt; myfunctionality.two #doctest: +ELLIPSIS
&lt;Two object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id88" id="getsitemanager" name="getsitemanager">9.22&nbsp;&nbsp;&nbsp;getSiteManager</a></h2>
<p>Get the nearest site manager in the given context.  If <cite>context</cite> is
<cite>None</cite>, return the global site manager.  If the <cite>context</cite> is not
<cite>None</cite>, it is expected that an adapter from the <cite>context</cite> to
<cite>IComponentLookup</cite> can be found.  If no adapter is found, a
<cite>ComponentLookupError</cite> is raised.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getSiteManager(context=None)</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.globalregistry import BaseGlobalComponents
&gt;&gt;&gt; from zope.component import IComponentLookup
&gt;&gt;&gt; sm = BaseGlobalComponents()

&gt;&gt;&gt; class Context(object):
...     def __init__(self, sm):
...         self.sm = sm
...     def __conform__(self, interface):
...         if interface.isOrExtends(IComponentLookup):
...             return self.sm

&gt;&gt;&gt; context = Context(sm)

&gt;&gt;&gt; from zope.component import getSiteManager

&gt;&gt;&gt; lsm = getSiteManager(context)
&gt;&gt;&gt; lsm is sm
True
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; sm = getSiteManager()
&gt;&gt;&gt; gsm is sm
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id89" id="getutilitiesfor" name="getutilitiesfor">9.23&nbsp;&nbsp;&nbsp;getUtilitiesFor</a></h2>
<p>Look up the registered utilities that provide an interface.  Returns
an iterable of name-utility pairs.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getUtilitiesFor(interface)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import getUtilitiesFor

&gt;&gt;&gt; list(getUtilitiesFor(IGreeter)) #doctest: +ELLIPSIS
[(u'', &lt;Greeter object at ...&gt;)]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id90" id="getutility" name="getutility">9.24&nbsp;&nbsp;&nbsp;getUtility</a></h2>
<p>Get the utility that provides interface.  Returns the nearest utility
to the context that implements the specified interface.  If one is not
found, raises <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt>.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getUtility(interface, name='', context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import getUtility

&gt;&gt;&gt; getUtility(IGreeter).greet('Jack')
'Hello Jack'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id91" id="handle" name="handle">9.25&nbsp;&nbsp;&nbsp;handle</a></h2>
<p>Call all of the handlers for the given objects.  Handlers are
subscription adapter factories that don't produce anything.  They do
all of their work when called.  Handlers are typically used to handle
events.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>handle(*objects)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc


&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()


&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated)

&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentCreated(doc))
&gt;&gt;&gt; doc.created.__class__.__name__
'datetime'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id92" id="implementedby" name="implementedby">9.26&nbsp;&nbsp;&nbsp;implementedBy</a></h2>
<p>Return the interfaces implemented for a class' instances.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implementedBy(class_)</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.interface import implementedBy
&gt;&gt;&gt; implementedBy(Greeter)
&lt;implementedBy __builtin__.Greeter&gt;
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class ISpecial(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; from zope.interface import classImplements
&gt;&gt;&gt; classImplements(Person, ISpecial)

&gt;&gt;&gt; from zope.interface import implementedBy

To get a list of all interfaces implemented by that class::

&gt;&gt;&gt; [x.__name__ for x in implementedBy(Person)]
['IPerson', 'ISpecial']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id93" id="implementer" name="implementer">9.27&nbsp;&nbsp;&nbsp;implementer</a></h2>
<p>Create a decorator for declaring interfaces implemented by a factory.
A callable is returned that makes an implements declaration on objects
passed to it.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implementer(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implementer
&gt;&gt;&gt; class IFoo(Interface):
...     pass
&gt;&gt;&gt; class Foo(object):
...     implements(IFoo)

&gt;&gt;&gt; &#64;implementer(IFoo)
... def foocreator():
...     foo = Foo()
...     return foo
&gt;&gt;&gt; list(implementedBy(foocreator))
[&lt;InterfaceClass __builtin__.IFoo&gt;]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id94" id="implements" name="implements">9.28&nbsp;&nbsp;&nbsp;implements</a></h2>
<p>Declare interfaces implemented by instances of a class This function
is called in a class definition.  The arguments are one or more
interfaces.  The interfaces given are added to any interfaces
previously declared.  Previous declarations include declarations for
base classes unless implementsOnly was used.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implements(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id95" id="implementsonly" name="implementsonly">9.29&nbsp;&nbsp;&nbsp;implementsOnly</a></h2>
<p>Declare the only interfaces implemented by instances of a class.  This
function is called in a class definition.  The arguments are one or
more interfaces.  Previous declarations including declarations for
base classes are overridden.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implementsOnly(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import implementsOnly

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; class NewPerson(Person):
...     implementsOnly(IStudent)
...     college = u&quot;&quot;

&gt;&gt;&gt; jack = NewPerson()
&gt;&gt;&gt; jack.college = &quot;New College&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
False
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id96" id="interface" name="interface">9.30&nbsp;&nbsp;&nbsp;Interface</a></h2>
<p>Using this class, you can define an interface.  To define an
interface, just inherit from <tt class="docutils literal"><span class="pre">Interface</span></tt> class.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>Interface(name, doc='')</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)
...     email = Attribute(&quot;Email Address&quot;)
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IHost(Interface):
...
...     def goodmorning(guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id97" id="moduleprovides" name="moduleprovides">9.31&nbsp;&nbsp;&nbsp;moduleProvides</a></h2>
<p>Declare interfaces provided by a module.  This function is used in a
module definition.  The arguments are one or more interfaces.  The
given interfaces are used to create the module's direct-object
interface specification.  An error will be raised if the module
already has an interface specification.  In other words, it is an
error to call this function more than once in a module definition.</p>
<p>This function is provided for convenience.  It provides a more
convenient way to call <tt class="docutils literal"><span class="pre">directlyProvides</span></tt> for a module.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>moduleProvides(*interfaces)</cite></li>
<li>See also: <a class="reference" href="#directlyprovides">directlyProvides</a></li>
</ul>
</blockquote>
<p>You can see an example usage in <cite>zope.component</cite> source itself.  The
<cite>__init__.py</cite> file has a statement like this:</p>
<pre class="literal-block">
moduleProvides(IComponentArchitecture,
               IComponentRegistrationConvenience)
</pre>
<p>So, the <cite>zope.component</cite> provides two interfaces:
<cite>IComponentArchitecture</cite> and <cite>IComponentRegistrationConvenience</cite>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id98" id="nolongerprovides" name="nolongerprovides">9.32&nbsp;&nbsp;&nbsp;noLongerProvides</a></h2>
<p>Remove an interface from the list of an object's directly provided
interfaces.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>noLongerProvides(object, interface)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import classImplements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; directlyProvides(jack, IStudent)

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
True
&gt;&gt;&gt; IStudent in providedBy(jack)
True
&gt;&gt;&gt; from zope.interface import noLongerProvides
&gt;&gt;&gt; noLongerProvides(jack, IStudent)
&gt;&gt;&gt; IPerson in providedBy(jack)
True
&gt;&gt;&gt; IStudent in providedBy(jack)
False
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id99" id="provideadapter" name="provideadapter">9.33&nbsp;&nbsp;&nbsp;provideAdapter</a></h2>
<p>It is recommended to use <a class="reference" href="#registeradapter">registerAdapter</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id100" id="providehandler" name="providehandler">9.34&nbsp;&nbsp;&nbsp;provideHandler</a></h2>
<p>It is recommended to use <a class="reference" href="#registerhandler">registerHandler</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id101" id="providesubscriptionadapter" name="providesubscriptionadapter">9.35&nbsp;&nbsp;&nbsp;provideSubscriptionAdapter</a></h2>
<p>It is recommended to use <a class="reference" href="#registersubscriptionadapter">registerSubscriptionAdapter</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id102" id="provideutility" name="provideutility">9.36&nbsp;&nbsp;&nbsp;provideUtility</a></h2>
<p>It is recommended to use <a class="reference" href="#registerutility">registerUtility</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id103" id="providedby" name="providedby">9.37&nbsp;&nbsp;&nbsp;providedBy</a></h2>
<p>Test whether the interface is implemented by the object.  Return true
if the object asserts that it implements the interface, including
asserting that it implements an extended interface.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>providedBy(object)</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
True
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class ISpecial(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; from zope.interface import classImplements
&gt;&gt;&gt; classImplements(Person, ISpecial)
&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;

To get a list of all interfaces provided by that object::

&gt;&gt;&gt; [x.__name__ for x in providedBy(jack)]
['IPerson', 'ISpecial']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id104" id="queryadapter" name="queryadapter">9.38&nbsp;&nbsp;&nbsp;queryAdapter</a></h2>
<p>Look for a named adapter to an interface for an object.  Returns an
adapter that can adapt object to interface.  If a matching adapter
cannot be found, returns the default.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryAdapter(object, interface=Interface, name=u'',
default=None, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk, 'ng')

&gt;&gt;&gt; queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id105" id="queryadapterincontext" name="queryadapterincontext">9.39&nbsp;&nbsp;&nbsp;queryAdapterInContext</a></h2>
<p>Look for a special adapter to an interface for an object.</p>
<p>NOTE: This method should only be used if a custom context needs to be
provided to provide custom component lookup. Otherwise, call the
interface, as in:</p>
<pre class="literal-block">
interface(object, default)
</pre>
<p>Returns an adapter that can adapt object to interface.  If a matching
adapter cannot be found, returns the default.</p>
<p>Context is adapted to IServiceService, and this adapter's 'Adapters'
service is used.</p>
<p>If the object has a __conform__ method, this method will be called
with the requested interface.  If the method returns a non-None value,
that value will be returned. Otherwise, if the object already
implements the interface, the object will be returned.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryAdapterInContext(object, interface, context,
default=None)</cite></li>
<li>See also: <a class="reference" href="#getadapterincontext">getAdapterInContext</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.globalregistry import BaseGlobalComponents
&gt;&gt;&gt; from zope.component import IComponentLookup
&gt;&gt;&gt; sm = BaseGlobalComponents()

&gt;&gt;&gt; class Context(object):
...     def __init__(self, sm):
...         self.sm = sm
...     def __conform__(self, interface):
...         if interface.isOrExtends(IComponentLookup):
...             return self.sm

&gt;&gt;&gt; context = Context(sm)

&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; sm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk)

&gt;&gt;&gt; from zope.component import queryAdapterInContext

&gt;&gt;&gt; queryAdapterInContext(jack, IDesk, sm) #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id106" id="querymultiadapter" name="querymultiadapter">9.40&nbsp;&nbsp;&nbsp;queryMultiAdapter</a></h2>
<p>Look for a multi-adapter to an interface for objects.  Returns a
multi-adapter that can adapt objects to interface.  If a matching
adapter cannot be found, returns the default.  The name consisting of
an empty string is reserved for unnamed adapters.  The unnamed adapter
methods will often call the named adapter methods with an empty string
for a name.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryMultiAdapter(objects, interface=Interface,
name=u'', default=None, context=None)</cite></li>
<li>See also: <a class="reference" href="#getmultiadapter">getMultiAdapter</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class IAdapteeOne(Interface):
...     pass

&gt;&gt;&gt; class IAdapteeTwo(Interface):
...     pass

&gt;&gt;&gt; class IFunctionality(Interface):
...     pass

&gt;&gt;&gt; class MyFunctionality(object):
...     implements(IFunctionality)
...     adapts(IAdapteeOne, IAdapteeTwo)
...
...     def __init__(self, one, two):
...         self.one = one
...         self.two = two

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(MyFunctionality)

&gt;&gt;&gt; class One(object):
...     implements(IAdapteeOne)

&gt;&gt;&gt; class Two(object):
...     implements(IAdapteeTwo)

&gt;&gt;&gt; one = One()
&gt;&gt;&gt; two = Two()

&gt;&gt;&gt; from zope.component import queryMultiAdapter

&gt;&gt;&gt; getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
&lt;MyFunctionality object at ...&gt;

&gt;&gt;&gt; myfunctionality = queryMultiAdapter((one,two), IFunctionality)
&gt;&gt;&gt; myfunctionality.one #doctest: +ELLIPSIS
&lt;One object at ...&gt;
&gt;&gt;&gt; myfunctionality.two #doctest: +ELLIPSIS
&lt;Two object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id107" id="queryutility" name="queryutility">9.41&nbsp;&nbsp;&nbsp;queryUtility</a></h2>
<p>This function is used to look up a utility that provides an interface.
If one is not found, returns default.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryUtility(interface, name='', default=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import queryUtility

&gt;&gt;&gt; queryUtility(IGreeter).greet('Jack')
'Hello Jack'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id108" id="registeradapter" name="registeradapter">9.42&nbsp;&nbsp;&nbsp;registerAdapter</a></h2>
<p>This function is used to register an adapter factory.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerAdapter(factory, required=None, provided=None,
name=u'', info=u'')</cite></li>
<li>See also: <a class="reference" href="#unregisteradapter">unregisterAdapter</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk, 'ng')

You can test it like this:

&gt;&gt;&gt; queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id109" id="registeredadapters" name="registeredadapters">9.43&nbsp;&nbsp;&nbsp;registeredAdapters</a></h2>
<p>Return an iterable of <cite>IAdapterRegistrations</cite>.  These registrations
describe the current adapter registrations in the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredAdapters()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk, 'ng2')


&gt;&gt;&gt; reg_adapter = list(gsm.registeredAdapters())
&gt;&gt;&gt; 'ng2' in [x.name for x in reg_adapter]
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id110" id="registeredhandlers" name="registeredhandlers">9.44&nbsp;&nbsp;&nbsp;registeredHandlers</a></h2>
<p>Return an iterable of <cite>IHandlerRegistrations</cite>.  These registrations
describe the current handler registrations in the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredHandlers()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc


&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()


&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated, info='ng3')

&gt;&gt;&gt; reg_adapter = list(gsm.registeredHandlers())
&gt;&gt;&gt; 'ng3' in [x.info for x in reg_adapter]
True

&gt;&gt;&gt; gsm.registerHandler(documentCreated, name='ng4')
Traceback (most recent call last):
...
TypeError: Named handlers are not yet supported
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id111" id="registeredsubscriptionadapters" name="registeredsubscriptionadapters">9.45&nbsp;&nbsp;&nbsp;registeredSubscriptionAdapters</a></h2>
<p>Return an iterable of <cite>ISubscriptionAdapterRegistrations</cite>.  These
registrations describe the current subscription adapter registrations
in the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredSubscriptionAdapters()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength, info='ng4')

&gt;&gt;&gt; reg_adapter = list(gsm.registeredSubscriptionAdapters())
&gt;&gt;&gt; 'ng4' in [x.info for x in reg_adapter]
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id112" id="registeredutilities" name="registeredutilities">9.46&nbsp;&nbsp;&nbsp;registeredUtilities</a></h2>
<p>This function return an iterable of <cite>IUtilityRegistrations</cite>.  These
registrations describe the current utility registrations in the
object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredUtilities()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, info='ng5')

&gt;&gt;&gt; reg_adapter = list(gsm.registeredUtilities())
&gt;&gt;&gt; 'ng5' in [x.info for x in reg_adapter]
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id113" id="registerhandler" name="registerhandler">9.47&nbsp;&nbsp;&nbsp;registerHandler</a></h2>
<p>This function is used to register a handler.  A handler is a
subscriber that doesn't compute an adapter but performs some function
when called.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerHandler(handler, required=None, name=u'', info='')</cite></li>
<li>See also: <a class="reference" href="#unregisterhandler">unregisterHandler</a></li>
</ul>
</blockquote>
<p>Note: In the current implementation of <tt class="docutils literal"><span class="pre">zope.component</span></tt> doesn't
support <cite>name</cite> attribute.</p>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc


&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()


&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated)

&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentCreated(doc))
&gt;&gt;&gt; doc.created.__class__.__name__
'datetime'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id114" id="registersubscriptionadapter" name="registersubscriptionadapter">9.48&nbsp;&nbsp;&nbsp;registerSubscriptionAdapter</a></h2>
<p>This function is used to register a subscriber factory.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerSubscriptionAdapter(factory, required=None,
provides=None, name=u'', info='')</cite></li>
<li>See also: <a class="reference" href="#unregistersubscriptionadapter">unregisterSubscriptionAdapter</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id115" id="registerutility" name="registerutility">9.49&nbsp;&nbsp;&nbsp;registerUtility</a></h2>
<p>This function is used to register a utility.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerUtility(component, provided=None, name=u'',
info=u'')</cite></li>
<li>See also: <a class="reference" href="#unregisterutility">unregisterUtility</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id116" id="subscribers" name="subscribers">9.50&nbsp;&nbsp;&nbsp;subscribers</a></h2>
<p>This function is used to get subscribers.  Subscribers are returned
that provide the provided interface and that depend on and are
computed from the sequence of required objects.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>subscribers(required, provided, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class SingleLineSummary:
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if '\n' in self.doc.summary:
...             return 'Summary should only have one line'
...         else:
...             return ''

&gt;&gt;&gt; class AdequateLength(object):
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(SingleLineSummary)
&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)

&gt;&gt;&gt; from zope.component import subscribers

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line', 'too short']

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot; * 1000)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line']

&gt;&gt;&gt; doc = Document(&quot;A Document&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['too short']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id117" id="unregisteradapter" name="unregisteradapter">9.51&nbsp;&nbsp;&nbsp;unregisterAdapter</a></h2>
<p>This function is used to unregister an adapter factory.  A boolean is
returned indicating whether the registry was changed.  If the given
component is None and there is no component registered, or if the
given component is not None and is not registered, then the function
returns False, otherwise it returns True.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterAdapter(factory=None, required=None,
provided=None, name=u'')</cite></li>
<li>See also: <a class="reference" href="#registeradapter">registerAdapter</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IDesk(Interface):
...     &quot;&quot;&quot;A frontdesk will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class FrontDeskNG(object):
...
...     implements(IDesk)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         bookings_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_frontdesk = FrontDeskNG(jack)

&gt;&gt;&gt; IDesk.providedBy(jack_frontdesk)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(FrontDeskNG,
...                     (IGuest,), IDesk, 'ng6')

You can test it like this:

&gt;&gt;&gt; queryAdapter(jack, IDesk, 'ng6') #doctest: +ELLIPSIS
&lt;FrontDeskNG object at ...&gt;

Now unregister:

&gt;&gt;&gt; gsm.unregisterAdapter(FrontDeskNG, name='ng6')
True

After unregistration:

&gt;&gt;&gt; print queryAdapter(jack, IDesk, 'ng6')
None
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id118" id="unregisterhandler" name="unregisterhandler">9.52&nbsp;&nbsp;&nbsp;unregisterHandler</a></h2>
<p>This function is used for unregistering a handler.  A handler is a
subscriber that doesn't compute an adapter but performs some function
when called.  A boolean is returned indicating whether the registry
was changed.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterHandler(handler=None, required=None,
name=u'')</cite></li>
<li>See also: <a class="reference" href="#registerhandler">registerHandler</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocument(Interface):
...
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)

&gt;&gt;&gt; class IDocumentAccessed(Interface):
...     doc = Attribute(&quot;The document that was accessed&quot;)

&gt;&gt;&gt; class DocumentAccessed(object):
...     implements(IDocumentAccessed)
...
...     def __init__(self, doc):
...         self.doc = doc
...         self.doc.count = 0

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentAccessed)
... def documentAccessed(event):
...     event.doc.count = event.doc.count + 1

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentAccessed)

&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentAccessed(doc))
&gt;&gt;&gt; doc.count
1

Now unregister:

&gt;&gt;&gt; gsm.unregisterHandler(documentAccessed)
True

After unregistration:

&gt;&gt;&gt; handle(DocumentAccessed(doc))
&gt;&gt;&gt; doc.count
0
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id119" id="unregistersubscriptionadapter" name="unregistersubscriptionadapter">9.53&nbsp;&nbsp;&nbsp;unregisterSubscriptionAdapter</a></h2>
<p>This function is used to unregister a subscriber factory.  A boolean
is returned indicating whether the registry was changed.  If the given
component is None and there is no component registered, or if the
given component is not None and is not registered, then the function
returns False, otherwise it returns True.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterSubscriptionAdapter(factory=None,
required=None, provides=None, name=u'')</cite></li>
<li>See also: <a class="reference" href="#registersubscriptionadapter">registerSubscriptionAdapter</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)

&gt;&gt;&gt; from zope.component import subscribers

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['too short']

Now unregister:

&gt;&gt;&gt; gsm.unregisterSubscriptionAdapter(AdequateLength)
True

After unregistration:

&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
[]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id120" id="unregisterutility" name="unregisterutility">9.54&nbsp;&nbsp;&nbsp;unregisterUtility</a></h2>
<p>This function is used for unregistering a utility.  A boolean is
returned indicating whether the registry was changed.  If the
given component is None and there is no component registered, or if
the given component is not None and is not registered, then the
function returns False, otherwise it returns True.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterUtility(component=None, provided=None,
name=u'')</cite></li>
<li>See also: <a class="reference" href="#registerutility">registerUtility</a></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet)

&gt;&gt;&gt; queryUtility(IGreeter).greet('Jack')
'Hello Jack'

Now unregister:

&gt;&gt;&gt; gsm.unregisterUtility(greet)
True

After unregistration:

&gt;&gt;&gt; print queryUtility(IGreeter)
None
</pre>
</div>
</div>
</div>
</body>
</html>
